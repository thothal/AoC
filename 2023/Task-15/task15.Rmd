---
params:
   task_nr: 15
   year: 2023
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  text_block[nzchar(text_block)] %>% 
   str_split(",") %>% 
    extract2(1L)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

The implementation of the hash function is straight forward. We just need to transfrom the 
character to its Ascii value and apply the hashing rules.

```{r get-solution-1}
calculate_hash <- function(tokens) {
  hash <- function(token) {
    chars <- str_split(token, "") %>% 
      extract2(1L) 
    cv <- 0L
    for (c in chars) {
      ascii <- charToRaw(c) %>% 
        as.integer()
      cv <- ((cv + ascii) * 17L) %% 256L
    }
    cv
  }
  map_int(tokens, hash)
}

init_sequence <- function(ops) {
  calculate_hash(ops) %>% 
    sum()
}

init_sequence(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part we maintain a list of tibbles, which store the current lense 
configuration for each box. Removing means removing the corresponding row, and adding
is implemented by either updating (if already existing) or adding the respective lense.

```{r get-solution-2}
fit_lenses <- function(lenses) {
  lense_id <- str_extract(lenses, "^[a-z]+") 
  box_id <- calculate_hash(lense_id)
  op <- str_extract(lenses, "[-=]")
  fs <- str_extract(lenses, "\\d+") %>% 
    as.integer()
  boxes <- rep(list(tibble(lbl = character(0L), focal_strength = integer(0L))),
               256L)
  for (i in seq_along(lense_id)) {
    lenses <- boxes[[box_id[i] + 1L]]
    if (op[i] == "-") {
      lenses <- lenses %>% 
        filter(lbl != lense_id[i])
    } else if (op[i] == "=") {
      
      if (lense_id[i] %in% lenses$lbl) {
        lenses <- lenses %>% 
          mutate(focal_strength = if_else(lbl %in% lense_id[i], fs[i], focal_strength))
      } else {
        lenses <- add_row(lenses, lbl = lense_id[i], focal_strength = fs[i])
      }
    }
    boxes[[box_id[i] + 1L]] <- lenses
  }
  imap_int(boxes, function(box, box_id) {
    fs <- box %>% 
      pull(focal_strength)
    sum(box_id * seq_along(fs) * fs)
  }) %>% 
    sum()
}

fit_lenses(puzzle_data)
```
