---
params:
   task_nr: 11
   year: 2023
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  text_block[nzchar(text_block)] %>% 
   str_split("") %>% 
    do.call(rbind, .)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

First, we get the indices of the rows and columns which are all empty and store them.
Then, we calculate the Manhattan distance for each pair of stars. For each empty column or 
row between their positions, we add one to account for the expansion. In fact, we add the
expansion factor as a parameter to the function, to use the same function for part 2.
We avoid physically increasing the star map in this way.

```{r get-solution-1}
calculate_distance <- function(stars, exp_factor = 2L) {
  expand <- list(row = apply(stars, 1L, \(r) all(r == ".")) %>% 
                   which(),
                 col = apply(stars, 2L, \(r) all(r == ".")) %>% 
                   which()
                 )
  star_pos <- which(stars == "#", arr.ind = TRUE)
  n_pos <- nrow(star_pos)
  nr_pairs <- n_pos * (n_pos - 1L) / 2L
  dist <- rep(NA_integer_, nr_pairs)
  for (i in 1:(n_pos - 1L)) {
    for (j in (i + 1L):n_pos) {
      star_1 <- star_pos[i, ]
      star_2 <- star_pos[j, ]
      dis <- abs(star_2 - star_1)
      row_f <- (exp_factor - 1L) * sum(expand$row <= max(star_1[1L], star_2[1L]) &
        expand$row >= min(star_1[1L], star_2[1L]))
      col_f <- (exp_factor - 1L) * sum(expand$col <= max(star_1[2L], star_2[2L]) &
        expand$col >= min(star_1[2L], star_2[2L]))
      idx <- (i - 1L) * n_pos - (i - 1L) * i / 2L + (j - i)
      dist[idx] <- sum(dis) + row_f + col_f
    }
  }
  sum(dist)
}

calculate_distance(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

All we need to do is to provide a larger expansion factor to the algorithm of part 1.

```{r get-solution-2}
calculate_distance(puzzle_data, 1000000L)
```
