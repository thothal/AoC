---
params:
   task_nr: 3
   year: 2023
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  text_block %>% 
    str_split("") %>% 
    do.call(rbind, .)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

First, we identify the positions of all ids. Then, we iterate over each id and check if 
there is any symbol adjacent to the spaces occupied by the id (thus, we need to store its
starting position, its row and its length). Eventuyll, we get all valid ids and need to
sum those to get the result.

```{r get-solution-1}
get_id_pos <- function(schematic) {
  map(seq_len(nrow(schematic)), function(i) {
    row <- schematic[i, ]
    is_nr <- row %>% 
      as.integer() %>% 
      suppressWarnings() %>% 
      is.na() %>% 
      not()
    rl <- rle(is_nr)
    start <- cumsum(rl$lengths) - rl$lengths + 1L
    id <- map_int(which(rl$values), ~ paste(row[start[.x]:(start[.x] + rl$lengths[.x] - 1L)], 
                                  collapse = "") %>% 
          as.integer())
    tibble(id = id, row = i, col = start[rl$values], len = rl$lengths[rl$values])
  }) %>% 
    list_rbind()
}

sum_part_numbers <- function(schematic) {
  ids <- get_id_pos(schematic)
  n <- nrow(ids)
  dd <- dim(schematic)
  is_valid <- logical(n)
  syms <- c(schematic) %>% 
    unique() %>% 
    str_subset("[.\\d]", TRUE)
  for (i in seq_len(n)) {
    id <- ids[i, ]
    cols <- seq(id$col - 1L, length.out = id$len + 2L)
    idx <- cbind(rep((id$row - 1L):(id$row + 1L), c(length(cols), 2L, length(cols))),
                 c(cols, range(cols), cols))
    idx <- idx[idx[, 1L] >= 1L & idx[, 1L] <= dd[1L] & 
                 idx[, 2L] >= 1L & idx[, 2L] <= dd[2L], , drop = FALSE]
    is_valid[i] <- any(schematic[idx] %in% syms)
  }
  ids %>% 
    filter(is_valid) %>% 
    summarize(chk = sum(id)) %>% 
    pull(chk)
}

sum_part_numbers(puzzle_data)

```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part we start again with the id positions. Then, for each `*` we check if
there are exactly **two** ids adjacent. If so, we multiply their ids and sum these ratios.

```{r get-solution-2}
sum_gear_ratios <- function(schematic) {
  ids <- get_id_pos(schematic)
  cand_pos <- which(schematic == "*", arr.ind = TRUE)
  n <- nrow(cand_pos)
  gear_ratio <- rep(NA_integer_, n)
  for (i in seq_len(n)) {
    cand <- cand_pos[i, ]
    cand_ids <- ids %>% 
      filter(row %in% (cand["row"] - 1L):(cand["row"] + 1L)) %>% 
      mutate(delta = map2_int(col, len, 
                              ~ min(abs(seq(.x, length.out = .y) - cand["col"])))) %>% 
      filter(delta <= 1L)
    if (nrow(cand_ids) == 2L) {
      gear_ratio[i] <- cand_ids %>% 
        pull(id) %>% 
        prod()
    }
  }
  sum(gear_ratio, na.rm = TRUE)
}

sum_gear_ratios(puzzle_data)
```
