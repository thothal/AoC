---
params:
   task_nr: 23
   year: 2023
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```

```{js cpp-highlighter, file = "Prism_CPP.js", echo = FALSE}
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE, message = FALSE, fig.align = "center",
  dev.args = list(bg = "transparent")
)
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}
```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(igraph)
library(collections)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(
  base_url,
  session_cookie
) %>%
  content(encoding = "UTF-8") %>%
  xml_find_all("///article") %>%
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>%
      str_split("\n") %>%
      extract2(1L)
  }
  map <- text_block[nzchar(text_block)] %>%
    str_split("") %>%
    do.call(rbind, .)
  start <- cbind(row = 1, col = which(map[1L, ] == "."))
  goal <- cbind(row = nrow(map), col = which(map[nrow(map), ] == "."))
  attr(map, "start") <- start
  attr(map, "goal") <- goal
  map
}

puzzle_data <- local({
  GET(
    paste0(base_url, "/input"),
    session_cookie
  ) %>%
    content(encoding = "UTF-8") %>%
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We construct a graph from the input data and then use a depth first search to find the 
longest path from the start to the goal. We also use a simple upper bound to prune the 
search space. The upper bound is based on the number of reachable nodes from the current
node that have not been visited yet. The slides are handled by removing the edges that
lead to invalid neighbors. This is done by checking the direction of the slide and 
removing the edges that lead to neighbors that are not in the direction of the slide. 
This way, we can ensure that we only consider valid paths when we encounter a slide.

The slides allow for an effective pruning of the search space, as they can lead to a large 
number of reachable nodes that are not valid. By removing the edges that lead to invalid neighbors, we can significantly reduce the number of nodes that we need to consider in our 
search, which can lead to a much faster solution.

```{r get-solution-1}
construct_graph <- function(winter_map, use_slides) {
  nr <- nrow(winter_map)
  nc <- ncol(winter_map)
  dirs <- rbind(
    "^" = c(-1L, 0L),
    ">" = c(0L, 1L),
    "v" = c(1L, 0L),
    "<" = c(0L, -1L)
  )
  G <- make_lattice(c(nr, nc), directed = TRUE, mutual = TRUE)
  V(G)$name <- c(outer(seq_len(nr), seq_len(nc), paste, sep = ","))
  walls <- which(winter_map == "#", arr.ind = TRUE)
  G <- delete_vertices(G, apply(walls, 1L, paste, collapse = ","))
  if (use_slides) {
    slides <- which(winter_map == "^" |
      winter_map == ">" |
      winter_map == "v" |
      winter_map == "<", arr.ind = TRUE)
    for (s in seq_len(nrow(slides))) {
      slide_pos <- slides[s, , drop = FALSE]
      slide_id <- paste(slide_pos[, 1L], slide_pos[, 2L], sep = ",")
      slide_dir <- winter_map[slide_pos]
      nbs <- slide_pos + dirs[slide_dir, ]
      nbs_id <- paste(nbs[, 1L], nbs[, 2L], sep = ",")
      invalid_nbs <- neighbors(G, slide_id, mode = "out") %>%
        setdiff(V(G)[nbs_id])
      G <- delete_edges(G, c(
        paste(slide_id, invalid_nbs$name, sep = "|"),
        paste(nbs_id, slide_id, sep = "|")
      ))
    }
  }
  G
}

hike_map <- function(winter_map, use_slides) {
  G <- construct_graph(winter_map, use_slides)
  make_key <- function(node) {
    paste(node[, 1L], node[, 2L], sep = ",")
  }
  dfs <- function(G, start, goal) {
    upper_bound <- function(u) {
      sum(!visited[reachable[[u]]])
    }
    d_goal <- distances(G, v = goal, mode = "in")
    adj <- adjacent_vertices(G, V(G)) %>%
      map(~ .x[order(d_goal[.x], decreasing = TRUE)])

    reachable <- ego(G, order = vcount(G), mode = "out")

    act_path <- best_path <- 0L
    visited <- rep(FALSE, vcount(G))
    stack <- stack()
    stack$push(list(node = start, next_child = 1L))
    visited[start] <- TRUE
    while (stack$size() > 0L) {
      state <- stack$peek()
      node <- state$node
      next_child <- state$next_child
      if (node == goal) {
        if (act_path > best_path) {
          best_path <- act_path
        }
        stack$pop()
        visited[node] <- FALSE
        act_path <- act_path - 1L
        next
      }
      remaining_max <- upper_bound(node)
      if (act_path + remaining_max <= best_path) {
        stack$pop()
        visited[node] <- FALSE
        act_path <- act_path - 1L
        next
      }
      nbs <- adj[[node]]
      if (next_child > length(nbs)) {
        stack$pop()
        visited[node] <- FALSE
        act_path <- act_path - 1L
        next
      }
      child <- nbs[next_child]
      stack$pop()
      stack$push(list(node = node, next_child = next_child + 1L))
      if (!visited[child]) {
        stack$push(list(node = child, next_child = 1L))
        act_path <- act_path + 1L
        visited[child] <- TRUE
      }
    }
    return(best_path)
  }
  start <- attr(winter_map, "start")
  goal <- attr(winter_map, "goal")
  dfs(G, V(G)[make_key(start)], V(G)[make_key(goal)])
}
hike_map(puzzle_data, TRUE)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

Theoretically, we could use the same approach as in part 1 and count the longest path in
the map where we have removed the slides. However, the search space is too large to be 
solved in a reasonable time with `R`. Hence, we re-implement the solution in C++ and use 
Rcpp to call the `C++` function from `R`. The `C++` implementation is a mere clone of the 
`R` implementation, but it is significantly faster. Removing the slides basically prevents
any pruning of the search space, as we can no longer use the slides to effectively reduce 
the number of reachable nodes. This means that we have to consider a much larger number of 
nodes in our search, which can lead to a much longer runtime. The `C++` implementation is 
able to handle this larger search space, while the `R` implementation is not.

```{Rcpp cpp-algorithm, file = "dfs.cpp", cache = TRUE}
```

```{r get-solution-2, cache = TRUE}
hike_map_no_slides <- function(winter_map) {
  G <- construct_graph(winter_map, use_slides = FALSE)
  get_node_id <- function(node) {
    V(G)[paste(node[, 1L], node[, 2L], sep = ",")] %>%
      as.integer() %>% 
      subtract(1L)
  }
  adj <- adjacent_vertices(G, V(G)) %>% 
    map(~ as.integer(.x) - 1L) %>% 
    unname()
  
  start <- attr(winter_map, "start")
  goal <- attr(winter_map, "goal")
  find_longest_path(adj, get_node_id(start), get_node_id(goal))
}
hike_map_no_slides(puzzle_data)
```
