---
params:
   task_nr: 14
   year: 2023
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  text_block[nzchar(text_block)] %>% 
   str_split("") %>% 
    do.call(rbind, .)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We implement the tilting with the help of `rle`. For each column of the matrix, we 
determine the `O` positions in the `rle` encoded values. Starting with the last position,
we move them towards te beginning until we hit a solid rock, or the start of the vector.
If, on the path, we hit a `.` tile, we simply swap the position. If we hit another stone
`O`, we add the respective `rle` values to avoid the need of keeping track of the current
rock queue.

We also include a `reverse` parameter, to allow moving rocks in the other position. In 
this case, we don't start at the end but with the first rock and stop once we hit the end
of the vector (and not the beginning).

```{r get-solution-1}
tilt <- function(stones, reverse = FALSE) {
  rl <- rle(stones)
  vals <- rl$values
  len <- rl$lengths
  st_pos <- which(vals == "O")
  if (!reverse) {
    dest <- 0L
    dir <- -1L
    st_pos <- rev(st_pos)
  } else {
    dest <- length(vals) + 1L
    dir <- 1L
  }
  for (pos in st_pos) {
    if (vals[pos] != "O") {
      ## stone was moved earlier
      next
    }
    new_pos <- pos + dir
    while (new_pos != dest && vals[new_pos] != "#") {
      if (vals[new_pos] == ".") {
        vals[new_pos] <- "O"
        vals[pos] <- "."
        old <- len[new_pos]
        len[new_pos] <- len[pos]
        len[pos] <- old
      } else if (vals[new_pos] == "O") {
        len[new_pos] <- len[new_pos] + len[pos]
        vals[pos] <- "x"
      }
      pos <- new_pos
      new_pos <- new_pos + dir
    }
  }
  nok <- vals == "x"
  rl <- list(
    values = vals[!nok],
    lengths = len[!nok]
  )
  class(rl) <- "rle"
  inverse.rle(rl)
}

tilt_stones <- function(map) {
  res <- apply(map, 2L, tilt)
  idx <- which(res == "O", arr.ind = TRUE)
  sum(nrow(map) - idx[, "row"] + 1L)
}
tilt_stones(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

To implement the other tilting directions we just need to use *rows* instead of
columns for horizontal tilts and use the `reverse` parameter to switch the direction.

To find the final state, we look for a cycle, as soon as we see a state which we have seen
before, we can fast-forward to the final state by calculating the cycle length and using
modulo arithmetics.


```{r get-solution-2}
tilt_cycles <- function(map, nr_rounds) {
  hash <- new.env(parent = emptyenv())
  i <- 1L
  while(i <= nr_rounds) {
    ## tilt north
    map <- apply(map, 2L, tilt)
    ## tilt west
    map <- apply(map, 1L, tilt) %>% 
      t()
    ## tilt south
    map <- apply(map, 2L, tilt, TRUE)
    ## tilt east
    map <- apply(map, 1L, tilt, TRUE) %>% 
      t()
    key <- paste(c(map), collapse = "")
    is_cycle <- exists(key, hash, inherits = FALSE)
    if (is_cycle) {
      cycle_length <- i - hash[[key]]
      offset <- (nr_rounds - hash[[key]]) %% cycle_length
      all_states <- mget(ls(hash, all.names = TRUE), hash)
      state <- which(all_states == (hash[[key]] + offset)) %>% 
        names()
      vals <- str_split(state, "")[[1L]]
      res <- array(vals, dim(map))
      idx <- which(res == "O", arr.ind = TRUE)
      return(sum(nrow(map) - idx[, "row"] + 1L))
    }
    hash[[key]] <- i
    i <- i + 1L
  }
}
tilt_cycles(puzzle_data, 1000000000L)
```
