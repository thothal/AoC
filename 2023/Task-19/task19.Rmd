---
params:
   task_nr: 19
   year: 2023
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(rlang)
library(igraph)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  sep <- which(!nzchar(text_block))
  parse_rule <- function(line) {
    rules <- str_remove_all(line, "^[a-z]+\\{|\\}")  %>% 
      str_extract_all("[^,]+") %>% 
      extract2(1L)
    is_dflt <- str_which(rules, ":", TRUE)
    rules <- str_replace_all(rules, ":(.*)", " ~ \"\\1\"")
    rules[is_dflt] <- paste0("TRUE ~ \"", rules[is_dflt], "\"")
    call2("case_when", !!!parse_exprs(rules))
  }
  parse_rules_lims <- function(line) {
    nm <- str_extract(line, "^\\w+")
    rule <- str_remove_all(line, "^\\w+\\{|\\}")
    dflt <- str_remove_all(line, "^.+,|\\}$")
    mtch <- str_match_all(rule, "([xmas])([<>])(\\d+):(\\w+)") %>% 
      extract2(1L)
    n <- nrow(mtch)
    res <- tibble(
      id = paste(nm, 1:n, sep = "_"),
      rule_nm = nm,
      order = 1:n,
      var = mtch[, 2L],
      val = as.integer(mtch[, 4]) + (mtch[, 3L] == ">")
    )
    res %>% 
      mutate(
        next_rule = lead(id) %>% 
          coalesce(dflt),
        target_true = if_else(mtch[, 3L] == ">", next_rule, mtch[, 5L]),
        target_false = if_else(mtch[, 3L] == ">", mtch[, 5L], next_rule)
      ) %>%
      mutate(across(starts_with("target"), 
                    ~ if_else(!str_detect(.x, "_\\d+$") & 
                                !str_detect(.x, "^[AR]$"),
                              paste0(.x, "_1"),
                              .x))) %>% 
      select(-next_rule)
  }
  rules <- text_block[1:(sep[1L] - 1L)]
  vals <- text_block[(sep[1L] + 1L):(length(text_block) - 1)] %>% 
    str_extract_all("\\d+") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("x", "m", "a", "s")) %>% 
    as_tibble() %>% 
    mutate(across(everything(), as.integer))
  nms <- str_extract_all(rules, "^[a-z]+")
  rules_lims <- map(rules, parse_rules_lims) %>% 
    list_rbind()
  rules <- map(rules, parse_rule) %>% 
    set_names(nms)
  
  list(vals = vals, rules = rules, rules_lims = rules_lims)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}

cat(puzzle[[1]])
```

### Solution

For the first part we constructed unevaluated `case_when` calls from the rules. We loop
through all rules and apply them in the context of the data frame containing the piece
values. The `case_when` statements return the next rule to apply. We continue this process 
until each tile falls either in the `R` or `A` category. Eventually we build the checksum
from the accepted pieces and return it.

```{r get-solution-1}
sort_pieces <- function(factory) {
  pieces <- factory$vals
  rules <- factory$rules
  pieces <- pieces %>% 
    mutate(rule_target = "in")
  while (!all(pieces$rule_target %in% c("R", "A"))) {
    pieces <- pieces %>% 
      mutate(rule = rules[rule_target]) %>% 
      rowwise() %>% 
      mutate(rule_target = if (rule_target %in% c("R", "A")) rule_target 
                               else eval_tidy(rule))
  }
  pieces %>% 
    filter(rule_target == "A") %>% 
    mutate(rating = x + m + a + s) %>% 
    summarize(rating = sum(rating)) %>% 
    pull(rating) %>% 
    sum()
}

sort_pieces(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we first construct a graph from the rules. Each node has 2 children,
one if the condition is `TRUE` and one if the condition is `FALSE`. (*N.B.* to avoid many
`if` clauses we transformed all the comparisons to a less-than-x form, that is instead of 
looking at `if x > 2 then A else B` we said `if x < 3 then B else A`).

Once the graph is constructed, we sort it topologically and update the limits of allowed
values for each node. These limits can be derived from the parent's limit as well as the
receptive condition at the node.

Eventually, we propagated all the intervals to `A` (and `R`), where we have to multiply
their lenghts and add all productes from all parents of `A`. Since the intervals where of 
the form `[lwr, upr)`, i.e. the upper limit was not part of the interval, we really just
need to look at the diff and do not need to add `1`.

```{r get-solution-2}
construct_graph <- function(rules) {
  vertices <- rules %>%
    mutate(
      id,
      label = paste0(id, ":\n", var, " < ", val),
      var,
      val,
      .keep = "none"
    )
  vertices <- bind_rows(
    vertices,
    tibble(id = c("R", "A"), label = id, var = NA_character_, val = NA_integer_)
  )
  ## use c(rbind(.)) trick to interweave values
  n <- nrow(rules)
  edges <- tibble(
    from = rep(rules$id, each = 2),
    to = c(rbind(rules$target_true, rules$target_false)), 
    label = rep(c("T", "F"), n),
    result = rep(c(TRUE, FALSE), n)
  )
  graph_from_data_frame(edges, directed = TRUE, vertices)
}

count_combinations <- function(rules) {
  G <- construct_graph(rules)
  nodes <- topo_sort(G)
  for (v in nodes) {
    parents <- neighbors(G, v, "in")
    if (length(parents) == 0L) {
      ## start node
      iv <- c(1L, 4001L)
      V(G)[v]$lims <- list(list(x = iv, m = iv, a = iv, s = iv))
    } else if (length(parents) == 1L) {
      edge <- E(G)[parents %->% v]
      V(G)[v]$lims <- parents$lims
      iv <- parents$lims[[1L]][[parents$var]]
      if (edge$result) {
        new_iv <- c(iv[1L], min(iv[2L], parents$val))
      } else {
        new_iv <- c(max(iv[1L], parents$val), iv[2L])
      }
      V(G)[v]$lims[[1L]][[parents$var]] <- new_iv
    } else {
      V(G)[v]$cnt <- 0L
      parents <- unique(parents)
      for (p in parents) {
        parent <- V(G)[p]
        edges <- E(G)[parent %->% v]
        for (e in edges) {
          edge <- E(G)[e]
          lims <- parent$lims[[1L]]
          iv <- lims[[parent$var]]
          if (edge$result) {
            new_iv <- c(iv[1L], min(iv[2L], parent$val))
          } else {
            new_iv <- c(max(iv[1L], parent$val), iv[2L])
          }
          lims[[parent$var]] <- new_iv
          n_cand <- map_dbl(lims, diff) %>% 
            prod()
          V(G)[v]$cnt <- V(G)[v]$cnt + n_cand
        }
      }
    }
  }
  V(G)["A"]$cnt
}
count_combinations(puzzle_data$rules_lims) %>% 
  print(digit = 16L)
```
