---
params:
   task_nr: 22
   year: 2023
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  res <- text_block[nzchar(text_block)] %>% 
    str_extract_all("\\d+") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("x0", "y0", "z0", "x1", "y1", "z1"))
  storage.mode(res) <- "integer"
  res
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

The first part is rather straight forward. We place pieces using matrix indexing and let
the pile sink by checking whether all spaces below te bottom row of a piece are empty. 
Then, for counting the pieces which can be disintegrated safely, we remove one piece at a 
time and check  whether any piece atop of it would move.

```{r get-solution-1}
build_pile <- function(bricks) {
  is_zero <- apply(bricks, 2L, \(c) any(c == 0L))
  bricks <- sweep(bricks, 2L, is_zero, `+`)
  dmax <- apply(bricks, 2L, max)
  dd <- c(max(dmax[3L], dmax[6L]),
          max(dmax[2L], dmax[5L]),
          max(dmax[1L], dmax[4L]))
  pile <- array(NA_integer_, dd)
  n <- nrow(bricks)
  for (i in seq_len(n)) {
    brick <- bricks[i, , drop = TRUE]
    idx <- expand.grid(z = dd[1L] - brick[3L]:brick[6L] + 1L,
                       y = brick[2L]:brick[5L],
                       x = brick[1L]:brick[4L]) %>% 
      as.matrix()
    pile[idx] <- i
  }
  tiles <- which(!is.na(pile), arr.ind = TRUE)
  tiles <- cbind(tiles, id = pile[tiles])
  ids <- tiles[order(-tiles[, 1L]), 4L] %>% 
    unique()

  down <- c(1L, 0L, 0L)
  for (id in ids) {
    piece <- tiles[tiles[, 4L] == id, , drop = FALSE]
    if (!any(piece[, 1L] == dd[1L])) {
      start_pos <- piece[, 1:3, drop = FALSE]
      pos <- t(t(start_pos) + down)
      bottom <- pos[pos[, 1L] == max(pos[, 1L]), , drop = FALSE]
      while (all(pos <= dd[1L]) && all(is.na(pile[bottom]))) {
        pos <- t(t(pos) + down)
        bottom <- pos[pos[, 1L] == max(pos[, 1L]), , drop = FALSE]
      }
      ## undo last move
      pos <- t(t(pos) - down)
      pile[start_pos] <- NA_integer_
      pile[pos] <- id
    }
  }
  pile
}

play_jenga_single <- function(bricks) {
  pile <- build_pile(bricks)
  tiles <- which(!is.na(pile), arr.ind = TRUE)
  tiles <- cbind(tiles, id = pile[tiles])
  bottom_rows <- tapply(tiles[, 1L], tiles[, 4L], max)
  ids <- tiles[order(-tiles[, 1L]), 4L] %>% 
    unique()
  down <- c(1L, 0L, 0L)
  cnt <- 0L
  for (id in ids) {
    piece <- tiles[tiles[, 4L] == id, , drop = FALSE]
    pile[piece[, 1:3, drop = FALSE]] <- NA_integer_
    top_row <- min(piece[, 1L])
    if (top_row > 1L) {
      on_top <- which(bottom_rows == top_row - 1L) %>% 
        names() %>% 
        as.integer()
      moved <- FALSE
      for (top_id in on_top) {
        top_piece <- tiles[tiles[, 4L] == top_id, , drop = FALSE]
        start_pos <- top_piece[, 1:3, drop = FALSE]
        pos <- t(t(start_pos) + down)
        bottom <- pos[pos[, 1L] == max(pos[, 1L]), , drop = FALSE]
        if (all(is.na(pile[bottom]))) {
          moved <- TRUE
          break
        }
      }
      cnt <- cnt + !moved
      pile[piece[, 1:3, drop = FALSE]] <- piece[, 4L]
    } else {
      cnt <- cnt + 1L
    }
  }
  cnt
}

play_jenga_single(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we check if a pieces moves and if it does, we remove it altogether 
and continue counting. We just have to make sure that we start removing neighboring pieces 
from the bottom row onwards. This algo is not really optimized and takes a bit too long 
for our taste but, it delivers the correct results.

```{r get-solution-2, cache = TRUE}
play_jenga_multi <- function(bricks) {
  pile <- build_pile(bricks)
  tiles <- which(!is.na(pile), arr.ind = TRUE)
  tiles <- cbind(tiles, id = pile[tiles])
  bottom_rows <- tapply(tiles[, 1L], tiles[, 4L], max)
  ids <- tiles[order(tiles[, 1L]), 4L] %>% 
    unique()
  down <- c(1L, 0L, 0L)
  original_pile <- pile
  cnt <- 0L
  for (id in ids) {
    piece <- tiles[tiles[, 4L] == id, , drop = FALSE]
    pile[piece[, 1:3, drop = FALSE]] <- NA_integer_
    top_row <- min(piece[, 1L])
    if (top_row > 1L) {
      on_top <- which(bottom_rows <= top_row - 1L) %>% 
        names() %>% 
        as.integer()
      on_top_pos <- tiles[tiles[, 4L] %in% on_top, , drop = FALSE]
      on_top <- on_top_pos[order(-on_top_pos[, 1L]), 4L] %>% 
        unique()
      for (top_id in on_top) {
        top_piece <- tiles[tiles[, 4L] == top_id, , drop = FALSE]
        start_pos <- top_piece[, 1:3, drop = FALSE]
        pos <- t(t(start_pos) + down)
        bottom <- pos[pos[, 1L] == max(pos[, 1L]), , drop = FALSE]
        if (all(is.na(pile[bottom]))) {
          cnt <- cnt + 1L
          pile[top_piece[, 1:3, drop = FALSE]] <- NA_integer_
        }
      }
      pile <- original_pile
    }
  }
  cnt
}
play_jenga_multi(puzzle_data)
```
