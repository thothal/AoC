---
params:
   task_nr: 12
   year: 2023
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  rpts <- text_block[nzchar(text_block)] %>% 
   str_split(" ")
  map(rpts, function(line) {
    chk <- str_split(line[[2L]], ",") %>% 
      extract2(1L) %>% 
      as.integer()
    rpt <- str_split(line[[1L]], "") %>% 
      extract2(1L)
    list(rpt = rpt, chk = chk)
  })
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

For the first part we implement a brute force algorithm (with some pruning though), where
we generate each replacement and count valid solutions.

```{r get-solution-1, cache = TRUE}
count_fixes_brute_force <- function(rpts) {
  
  is_valid <- function(rpt, chk) {
    n <- length(rpt)
    has_q <- rpt == "?"
    if (any(has_q)) {
      last <- which(has_q) %>% 
        max()
      rpt <- rpt[(last + 1L):length(rpt)]  
    }
    partial <- any(has_q)
    rl <- rle(rpt)
    ids <- which(rl$values == "#")
    nb  <- length(ids)
    
    ## more # blocks than allowed
    if (nb > length(chk)) {
      return(FALSE)
    }
    if (!partial && nb != length(chk)) {
      return(FALSE)
    }
    chk <- tail(chk, nb)
    for (i in seq_len(nb)) {
      len <- rl$lengths[ids[i]]
      want <- chk[i]
      
      if (i > 1L || !partial) {
        ## finished blocks must match exactly
        if (len != want) {
          return(FALSE)
        }
      } else {
        ## last block & partial may be smaller but not larger
        if (len > want) {
          return(FALSE)
        }
      }
    }
    TRUE
  }
  
  count <- function(rpt, chk, pos = length(rpt)) {
    if (pos <= 0L) {
      return(1L)
    }
    
    # Skip already fixed positions
    while (pos >= 1L && rpt[pos] %in% c(".", "#")) {
      pos <- pos - 1L
    }
    
    if (pos <= 0L) {
      return(1L)
    }
    
    rpt1 <- rpt2 <- rpt
    
    rpt1[pos] <- "#"
    rpt2[pos] <- "."
    
    total <- 0L
    
    if (is_valid(rpt1, chk)) {
      total <- total + Recall(rpt1, chk, pos - 1L)
    }
    
    if (is_valid(rpt2, chk)) {
      total <- total + Recall(rpt2, chk, pos - 1L)
    }
    total
  }
  map_int(rpts, ~ count(.x$rpt, .x$chk)) %>% 
    sum()
}

count_fixes_brute_force(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, brute force is out of question and we should use a smarter algorithm.
Hence, we fall back to dynamic programming, where a state `(i, j, run)` is given by:

* `i`: actual position in the string (from the beginning).
* `j`: number of blocks already satisfying the checksum.
* `run`: length of the current block.

At each position we do the following:

1. If the character is `.` or `?` we can replace it by a `.` and we need to check the 
following points:
  * If `run > 0` the actual block ends and it must fit **exactly** the current check sum,
    i.e. `run == chk[j]`. Then we set `j++` and `run = 0`.
  * If `run == 0` then we simply continue.
1. If the character is `.` or `#` we can replace it by a `#` and we need to check the 
following points:
  * We are enlarging the current block (`run++`), which is only possibly if 
    `run <= chk[j]` and `j < length(chk)` (the last condition means that there is at least
    still one "open" block).
    
We stop the algorithm if `i == length(pattern) + 1L` and check if the current block (if we 
are currently building one) is matching the last checksum and that all checksums were 
"used". If this is the case we can return 1 and 0 otherwise.

Additionally, we use memoisation to avoid recalculating known states.

```{r get-solution-2, cache = TRUE}
new_puzzle_data <- map(puzzle_data, function(grp) {
  list(
    rpt = c(rep(c(grp$rpt, "?"), 4L), grp$rpt),
    chk = rep(grp$chk, 5L)
  )
})

count_fixes_dp <- function(puzzle_data) {
  solve <- function(pattern, chk) {
    memo <- new.env(parent = emptyenv())
    N <- length(pattern)
    K <- length(chk)
    dp <- function(i, j, run) {
      key <- paste(i, j, run, sep = "_")
      if (exists(key, memo, inherits = FALSE)) {
        return(memo[[key]])
      }
      if (i == N + 1L) {
        ## we processed the last character in the pattern
        if (run > 0L) {
          ## if there is still an open block, check it
          if (run == chk[j]) {
            ## last block properly filled
            j <- j + 1L
          } else {
            ## last block is not filled
            memo[[key]] <<- 0
            return(0)
          }
        }
        ## j == K + 1L we filled all blocks
        res <- if_else(j == K + 1L, 1L, 0L)
        memo[[key]] <<- res
        return(res)
      }
      res <- 0
      sym <- pattern[i]
      ## option "."
      if (sym %in% c(".", "?")) {
        if (run == 0L) {
          ## we are not in a block currently => simply proceed with the next character
          res <- res + Recall(i + 1L, j, 0L)
        } else if (j <= K && run == chk[j]) {
          ## we still have blocks available and the current block is properly filled
          res <- res + Recall(i + 1L, j + 1L, 0L)
        }
      }
      ## option "#"
      if (sym %in% c("#", "?")) {
        if (j <= K && run < chk[j]) {
          ## we can still fill the current block => add 1 to its length anc ontinue
          res <- res + Recall(i + 1L, j, run + 1L)
        }
      }
      memo[[key]] <<- res
      res
    }
    dp(1L, 1L, 0L)
  }

  map_dbl(puzzle_data, ~ solve(.x$rpt, .x$chk)) %>%
    sum()
}
res <- count_fixes_dp(new_puzzle_data)  
print(res, digits = 16)
```
