---
params:
   task_nr: 9
   year: 2020
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    as.numeric()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We sort the preamble and use 2 pointers like in [Day 1 @ 2020](2020_task1.html) to 
determine whether a number is valid. We exit as soon as we hit the first invalid number.

```{r get-solution-1}
is_valid<- function(nrs, target) {
  nrs <- sort(nrs)
  i <- 1L
  j <- length(nrs)
  while (i < j) {
    s <- nrs[i] + nrs[j]
    if (s == target && nrs[i] != nrs[j]) {
      return(TRUE)
    } else if (s < target) {
      i <- i + 1L
    } else { # s > target
      j <- j - 1L
    }
  }
  FALSE
}

find_bad_number <- function(orig_seq, block_length = 25L) {
  n <- length(orig_seq)
  i <- 1L
  while (i < n - block_length) {
    preamble <- orig_seq[seq(i, length.out = block_length)]
    target <- orig_seq[i + block_length]
    if (!is_valid(preamble, target)) {
      return(target)
    }
    i <- i + 1L
  }
  NA_real_
}

(bad <- find_bad_number(puzzle_data))
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]] %>% str_replace_all(fixed("*"), "\\*"))
```

### Solution

We use a sliding window where we add numbers until the sum is greater than the target sum.
In this case we subtract values from the left (thus effectively moving the window) 
until we are smaller or equal than the target and continue until we find a match.

```{r get-solution-2}
get_encryption_weakness <- function(orig_seq, target = bad) {
  left <- 1L
  curr_sum <- 0
  n <- length(orig_seq)
  
  for (right in seq_len(n)) {
    curr_sum <- curr_sum + orig_seq[right]
    
    while (curr_sum > target && left <= right) {
      curr_sum <- curr_sum - orig_seq[left]
      left <- left + 1L
    }
    
    if (curr_sum == target) {
      return (sum(range(orig_seq[left:right])))
    }
  }
  NA_real_
}

get_encryption_weakness(puzzle_data, bad)
```
