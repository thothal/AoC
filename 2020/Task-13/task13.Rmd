---
params:
   task_nr: 13
   year: 2020
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(numbers)
library(bit64)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  list(
    time = as.integer(text_block[[1L]]),
    bus = str_split(text_block[[2L]], ",")[[1L]] %>% 
      as.integer() %>% 
      suppressWarnings()
  )
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We need to to use the modulo operation to determine the remainder for each schedule. Then,
by subtracting this from the schedule time we know when each bus will arrive the next 
time and we can determine the bus which will arrive next.

```{r get-solution-1}
find_bus <- function(schedule) {
  arrives_in <- schedule$bus - (schedule$time %% schedule$bus)
  idx <- which.min(arrives_in)
  arrives_in[idx] * schedule$bus[idx]
}

find_bus(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]] %>% str_replace_all(fixed("*"), "\\*"))
```

### Solution

We use the 
[Chinese remainder theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem) 
to solve the sequence of congruence equations:
$$
\begin{align}
x&\equiv -a_1 \bmod m_1\\
x&\equiv -a_2 \bmod m_2\\
\vdots&\\
x&\equiv -a_n \bmod m_n
\end{align}
$$
where $x$ is the timestamp which we are looking for, $a_i$ are the offsets at which
each bus should arrive (determined by the position in the schedule) and $m_i$ are the 
respective schedules of each bus. If bus $i$ should arrive at $x + a_i$ we know that
$x + a_i \equiv 0 \bmod m_i$ or equivalently $x \equiv -a_i \bmod m_i$.

```{r get-solution-2}
find_timestamp <- function(schedule) {
  schedule <- schedule$bus
  keep <- !is.na(schedule)
  a <- -(which(keep) - 1L)
  m <- schedule[keep]
  M <- prod(m) / m
  crt <- map2(m, M, extGCD) %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("gcd", "r", "s"))
  e <- crt[, "s"] * M
  as.integer64(sum(a * e) %% prod(m))
}

find_timestamp(puzzle_data) 
```
