---
params:
   task_nr: 24
   year: 2020
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_extract_all("[sn]?[ew]")
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

A step to `EAST` or `WEST` can be encoded by `(0, +/-2)` while a step to the diagonals
can be encoded by `(+/-1, +/-1)`. Thus, we simply follow all instructions, get the end 
position and count how often eahc position occur. Positions which occur an even amount of 
times are removed and counting the remaining tiles gives us the final answer.

```{r get-solution-1}
flip_tiles <- function(instructions) {
  dirs <- rbind(
    ne = c(-1L, 1L),
    e  = c(0L, 2L),
    se = c(1L, 1L),
    sw = c(1L, -1L),
    w  = c(0L, -2L),
    nw = c(-1L, -1L)
  )
  flip <- function(instruction) {
    pos <- cbind(0L, 0L)
    for (dir in instruction) {
      pos <- pos + dirs[dir, ]
    }
    pos %>% 
      set_colnames(c("row", "col"))
  }
  map(instructions, ~ flip(.x) %>% as_tibble()) %>% 
    list_rbind()
}

tiles <- flip_tiles(puzzle_data)

tiles %>% 
  count(row, col) %>% 
  filter(n %% 2L != 0L) %>% 
  nrow()
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]] %>% str_replace_all(fixed("*"), "\\*"))
```

### Solution

To solve the second part, we generate all neighbors of the existing tiles, and count the
black ones. Then, we update the color according to the rules.

```{r get-solution-2}
animate_tiles <- function(tiles, days) {
  tiles <- tiles %>% 
    count(row, col) %>% 
    filter(n %% 2 != 0L) %>% 
    select(-n)
  dirs <- rbind(
    ne = c(-1L, 1L),
    e  = c(0L, 2L),
    se = c(1L, 1L),
    sw = c(1L, -1L),
    w  = c(0L, -2L),
    nw = c(-1L, -1L)
  )
  for (i in seq_len(days)) {
    neighbors_list <- map2(tiles$row, tiles$col, ~ t(t(dirs) + c(.x, .y)))
    all_coords <- do.call(rbind, neighbors_list) %>% 
      set_colnames(c("row", "col")) %>% 
      as_tibble()
    
    candidates <- bind_rows(
      tiles,
      all_coords
    ) %>% 
      distinct() %>% 
      left_join(
        tiles %>% 
          mutate(is_black = TRUE),
        c("row", "col")
      ) %>% 
      mutate(is_black = coalesce(is_black, FALSE))
    
    neighbor_count <- candidates %>% 
      inner_join(candidates %>% 
                   mutate(
                     r1 = row - 1L,
                     r2 = row + 1L,
                     c1 = col - 2L,
                     c2 = col + 2L),
                 by = join_by(between(row, r1, r2),
                              between(col, c1, c2))) %>% 
      filter(row.x != row.y | col.x != col.y, is_black.y) %>% 
      group_by(row = row.x, col = col.x, is_black = is_black.x) %>% 
      summarize(n1 = n(), .groups = "drop")
    
    tiles <- neighbor_count %>%
      mutate(
        is_black = case_when(
          (is_black & n1 %in% 1:2) ~ TRUE,
          (!is_black & n1 == 2L) ~ TRUE,
          TRUE ~ FALSE
        )
      ) %>%
      filter(is_black) %>%
      select(row, col)
  }
  tiles %>% 
    nrow()
}


animate_tiles(tiles, 100L)
```
