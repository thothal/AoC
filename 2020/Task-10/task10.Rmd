---
params:
   task_nr: 10
   year: 2020
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(bit64)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    as.integer()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We sort the adapters according to their joltage, add the charging outlet to the beginning 
and the device adapter to the end, form the differences, count them and multiply them to 
get the answer.

```{r get-solution-1}
get_joltage_kpi <- function(adapters) {
  joltages <- sort(adapters)
  c(0L, joltages, max(joltages) + 3L) %>% 
    diff() %>% 
    table() %>% 
    prod()
}
get_joltage_kpi(puzzle_data)  
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]] %>% str_replace_all(fixed("*"), "\\*"))
```

### Solution

We use dynamic programming to count the number of ways to connect the charging outlet
to the device adapter. The idea is that there is exactly 1 way to connect the charging 
outlet. Then, we iterate over each adapter and add the number of possibilities for 
adapter x to all adapaters it can be connected to, that is all with a joltage not larger 
than 3 units. Eventually, we get the number of connection possibilities for the largest
joltage.

```{r get-solution-2}
count_paths <- function(adapters) {
  joltages <- sort(adapters)
  joltages <- c(0L, joltages, max(joltages) + 3L)
  dp <- integer64(length(joltages)) %>% 
    set_names(joltages)
  dp
  dp["0"] <- as.integer64(1L)
  js <- joltages
  for (j in js) {
    for (delta in 1:3) {
      dp[as.character(j + delta)] <- dp[as.character(j + delta)] + dp[as.character(j)]
    }
  }
  dp[as.character(max(joltages))]
}

count_paths(puzzle_data)
```
