---
params:
   task_nr: 8
   year: 2025
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(igraph)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  res <- text_block[nzchar(text_block)] %>% 
    str_extract_all("\\d+") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("x", "y", "z"))
  storage.mode(res) <- "integer"
  res
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We calculate the Euclidian distance between all junction boxes and connect them in order
of increasing distance until all the required boxes are connected. We keep track of
connected junction boxes by using a graph, where the nodes represent the junction boxes.
Eventually, we can calculate the maximum length of the connected junction boxes by 
looking at the size of the three largest components in the graph. The solution for part 1 
is then given by the product of these sizes.

```{r get-solution-1}
get_index <- function(k, n) {
  ## k an index in the lower triangle of an n x n matrix (without the diagonal)
  col <- ceiling(((2L * n - 1L) - sqrt((2L * n - 1L) ^ 2L - 8L * k)) / 2L)
  c_prev <- (col - 1L) * n - (col - 1L) * col / 2L
  offset <- k - c_prev
  row <- col + offset
  c(row = row, col = col)
}

connect_network <- function(junction_boxes, nr_boxes) {
  n <- nrow(junction_boxes)
  network <- make_empty_graph(n, directed = FALSE)
  dd <- dist(junction_boxes)
  vals <- c(dd) %>% 
    sort()
  i <- 1L
  nr_comp <- components(network)$no
  while (i <= nr_boxes && nr_comp > 1L) {
    idx <- get_index(which(dd == vals[i]), n)
    network <- add_edges(network, idx)
    nr_comp <- components(network)$no
    i <- i + 1L
  }
  xc <- junction_boxes[idx, "x"] %>% 
    prod()
  list(max_len = components(network)$csize %>% 
         sort(decreasing = TRUE) %>% 
         extract(1:3) %>% 
         prod(na.rm = TRUE),
       xc = xc)
}
connect_network(puzzle_data, 1000L)$max_len
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For part 2 we keep connecting junction boxes until all are connected (i.e. there is only
one big component). We then return the product of the x-coordinates of the last two 
junction boxes that were connected.

```{r get-solution-2, cache = TRUE}
connect_network(puzzle_data, Inf)$xc
```
