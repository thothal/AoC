---
params:
   task_nr: 2
   year: 2025
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(tidyr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  text_block[nzchar(text_block)] %>% 
    str_extract_all("\\d+") %>% 
    extract2(1L) %>%
    as.numeric() %>%
    matrix(ncol = 2L, byrow = TRUE) %>% 
    set_colnames(c("from", "to")) %>% 
    as_tibble()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

For the first part we look at the digits of the limits. If both limits have an odd number 
of digits, there are no valid codes. If one limit has an odd and the other an even number 
of digits, we generate the largest (smallest) valid number with the even number of digits.
Once we determined these 2 limits, we generate a list of valid digits at each position.
Since we are looking at pairs, we only need to do that for the first half of positions. If
the lower and the upper limit have the same digit at position i, we can only need to use 
that digit. This reduces the amount of numbers to generate quite a bit.
Eventually we generate all numbers and check which are within the limits.

*N.B.* Some functionality (especially `NA` and `include_middle`) is only needed for the
second part.

```{r get-solution-1}
get_nr_digits <- function(x) {
  n <- log10(x) %>% 
    ceiling() %>% 
    as.integer()
  if (n == log10(x)) {
    n <- n + 1L
  }
  n
}
to_digits <- function(x) {
  n <- get_nr_digits(x)
  digits <- integer(n)
  for (i in n:1) {
    digits[i] <- x %% 10L
    x <- x %/% 10L
  }
  digits
}

generate_twins <- function(..., len = NA_integer_) {
  nr <- paste(..., sep = "")
  if (any(is.na(c(...)))) {
    -1
  } else {
    paste(nr, nr, sep = "") %>% 
      as.numeric()
  }
}

generate_numbers <- function(from, to, gen_fn, include_middle) {
  c1 <- get_nr_digits(from)
  c2 <- get_nr_digits(to)
  ## assumption: max one digit longer
  stopifnot(abs(c1 - c2) <= 1L)
  add <- NULL
  if (c1 %% 2L == 1L && c2 %% 2L == 1L) {
    if (!include_middle) {
      ## both limits are odd => no valid codes
      return(numeric(0L))
    } else {
      lwr <- from
      upr <- to
      len <- c1
    }
  } 
  if (c1 %% 2L == 0L && c2 %% 2L == 1L) {
    if (c2 > 1L) {
      base <- rep("1", c2) %>% 
        paste(collapse = "") %>% 
        as.numeric()
      cand <- 1:9 * base
      add <- cand[cand >= from & cand <= to]
    }
    lwr <- from
    upr <- paste(rep("9", c1), collapse = "") %>% 
      as.numeric()
    len <- c1
  } else if (c1 %% 2L == 1L && c2 %% 2L == 0L) {
    if (c1 > 1L) {
      base <- rep("1", c1) %>% 
        paste(collapse = "") %>% 
        as.numeric()
      cand <- 1:9 * base
      cand <- cand + paste(rep("0", c1 - 1L), collapse = "") %>% 
        as.numeric()
      add <- cand[cand >= from & cand <= to]
      
    }
    lwr <- paste(c("1", rep("0", c2 - 1L)), collapse = "") %>% 
      as.numeric()
    upr <- to
    len <- c2
  } else {
    lwr <- from
    upr <- to
    len <- c1
  }
  d1 <- to_digits(lwr)
  d2 <- to_digits(upr)
  rng <- rep(list(c(0:9, NA_integer_)), length(d1) / 2L)
  for (i in seq_along(rng)) {
    if (d1[[i]] == d2[[i]]) {
      if (i == 1L) {
        rng[[i]] <- d1[i]
      } else {
        rng[[i]] <- c(d1[i], NA_integer_)
      }
    } else {
      break
    }
  }
  comb <- do.call(expand.grid, rng) %>% 
    filter(pmap_lgl(., function(...) {
      vals <- c(...)
      na_pos <- is.na(vals)
      !any(na_pos) || all(na_pos[which(na_pos)[1L]:length(vals)])
    }))
  res <- comb %>%
    mutate(nr = pmap(., ~ gen_fn(..., len = len))) %>% 
    unnest(c(nr)) %>% 
    distinct(nr) %>% 
    filter(between(nr, from, to)) %>%
    pull(nr)
  if (include_middle) {
    res <- c(res, add)
  }
  res
}

find_invalid_codes <- function(ranges, gen_fn, include_middle) {
  ranges %>% 
    mutate(chk = map2(from, to, 
                      ~ generate_numbers(.x, .y, gen_fn, include_middle))) %>%
    summarize(total = sum(unlist(chk))) %>%
    pull(total)
}

find_invalid_codes(puzzle_data, generate_twins, FALSE)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we also allow for `NA` in the candidate lists (except for the first
position). But we look only for candidates which have a consecutive block of `NAs` at the
end. After removing `NAs` we have a short block, which fulfills the requirement only if
its length is a divisor of the total length. In case of one uneven limit, we have to make
sure to include the single valid point made of the same digit (if it is within the 
bounds).

```{r get-solution-2}
generate_tuples <- function(..., len) {
  vals <- c(...)
  vals <- vals[!is.na(vals)]
  if (length(vals) == 0L || len %% length(vals) != 0L) {
    numeric(0L)
  } else {
    nr <- paste(vals, collapse = "")
    rep(nr, len / length(vals)) %>% 
      paste(collapse = "") %>% 
      as.numeric()
  }
}

find_invalid_codes(puzzle_data, generate_tuples, TRUE)
```
