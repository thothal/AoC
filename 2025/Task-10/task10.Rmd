---
params:
   task_nr: 10
   year: 2025
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(lpSolve)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L)
  }
  goal <- text_block[nzchar(text_block)] %>% 
    str_extract_all("[.#]") %>% 
    map(~ if_else(.x == ".", 0L, 1L))
  buttons <- text_block[nzchar(text_block)] %>% 
    str_extract_all("(\\(\\d+(,\\d+)*\\))+") %>% 
    map(function(buttons) {
      bits <- str_extract_all(buttons, "\\d+") %>% 
        map(as.integer)
      mb <- unlist(bits) %>% 
        max()
      m <- matrix(0L, nrow = length(bits), ncol = mb + 1)
      for (i in seq_along(bits)) {
        m[i, bits[[i]] + 1L] <- 1L
      }
      t(m)
    })
  joltages <- text_block[nzchar(text_block)] %>% 
    str_extract_all("\\{.*\\}") %>% 
    map(~ map_int(str_extract_all(.x, "\\d+")[[1L]], as.integer))
  transpose(
    list(goal = goal, buttons = buttons, joltages = joltages)
  )
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

Buttons are represented as a matrix $A\in \{0,1\}^{m\times n}$ where $m$ is the number of 
lights and $n$ is the number of buttons:
$$
A_{i,j} = 1 \Leftrightarrow \text{Button}\; i\; \text{switches light}\; j
$$ 

The goal is represented as a vector $b\in \{0,1\}^m$. We want to find $y \in \mathbb{N}^n$ 
which represents the number of button presses. Hence, we solve

$$
\min \|y\|_1 = \min\sum_i |y_i|
$$
subjected to:
$$
Ay\equiv b \bmod 2
$$
*N.B.* As we are anyways taking the modulo 2, we can assume without loss of generality
that $y\in \{0,1\}^n$ (2 pushes of the same button will result in the same
state as before the pushes).

This can be reformulated as the following integer linear program by introducing auxiliary 
integer variables $z\in \mathbb{Z}^m$ to capture the modulo 2 operation:

$$
Ay-2z = b,\; y\in \{0,1\}^n,\,z\in \mathbb{Z}^m
$$
Thus, we solve for $\tilde z := (y, z)^\top$ and the following constraints:
$$
\begin{aligned}
\text{minimize}\quad & \|y\|_1\\[0.5em]
\text{s.t.} \quad &
\tilde A\tilde z = b\\[0.5em]
\text{where} \quad &
\tilde A := [A\; \vert-2\cdot I_m] =\left[
\begin{array}{l|rrrrr}
 & -2 & 0 & 0 &\cdots & 0\\
 & 0 & -2 & 0&\cdots & 0\\
 A & 0 & 0 & -2 & \cdots & 0\\
 & \vdots & \vdots & \vdots & \ddots & \vdots\\
 & 0 & 0 & 0 & \cdots &-2\\
\end{array}
\right], \\
& \tilde z := \begin{bmatrix}
y\\
z
\end{bmatrix},\\
& \tilde A \in \mathbb{N}^{m\times(n+m)},  
\tilde z \in \mathbb{Z}^{(n+m)}, b \in \{0,1\}^m
\end{aligned}
$$

This *integer linear program* can be solved using the `lpSolve` package in R.

```{r get-solution-1}
solve_lights <- function(manual) {
  A <- as.matrix(manual$buttons)
  b <- as.vector(manual$goal)
  m <- nrow(A)
  n <- ncol(A)
  total_vars <- n + m
  obj <- rep(1:0, c(n, m))
  constr_mat <- matrix(0L, m, total_vars)
  constr_mat[, 1:n] <- A
  constr_mat[, (n + 1L):total_vars] <- -2L * diag(m)
  constr_dir <- rep("==", m)
  constr_rhs <- b
  result <- lp(
    "min",
    obj,
    constr_mat,
    constr_dir,
    constr_rhs,
    all.bin = FALSE,
    int.vec = (n + 1L):total_vars,
    binary.vec = 1:n
  )
  sum(result$solution[1:n])
}

solve <- function(manual, solver) {
  map_int(manual, solver) %>% 
    sum()
}

solve(puzzle_data, solve_lights)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

The second part is even more straightforward. We want to find a vector $y\in \mathbb{N}^n$ 
such that $Ay = b$ where $b$ corresponds to the joltage levels. Thus, we simply drop the 
modulo restriction and use the joltage values as $b$.

```{r get-solution-2}
solve_joltage <- function(manual) {
  A <- as.matrix(manual$buttons)
  b <- as.vector(manual$joltage)
  m <- nrow(A)
  n <- ncol(A)
  obj <- rep(1, n)
  constr_dir <- rep("==", m)
  constr_rhs <- b
  all_bin <- rep(c(TRUE, FALSE), c(n, m))
  result <- lp(
    "min",
    obj,
    A,
    constr_dir,
    constr_rhs,
    int.vec = 1:n
  )
  sum(result$solution)
}

solve(puzzle_data, solve_joltage)
```
