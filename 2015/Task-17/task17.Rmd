---
params:
   task_nr: 17
   year: 2015
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   force_year <- "2015"
   
   year <- dplyr::coalesce(force_year, format(Sys.Date(), "%Y"))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}
```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  as.integer(text_block)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
example_data <- c(20L, 15L, 10L, 5L, 5L)
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We solve this puzzle via dynamic programming. We create a vector where each entry 
represents the amount of ways to reach a sum equal to the index. That is $dp_0$ indicates
the amount of ways to build a sum equal 0. We set $dp_0$ to 1 (there is only one way to
build the sum 0, namely by adding no numbers as all numbers are greater than 0).

We then use two loops, the forst iterates over each number, the second loops from the 
maximum capacity down to the current number. We updated the vector simply by adding the
up the values.

```{r get-solution-1}
count_sums <- function(numbers, capacity) {
  res <- vector("integer", capacity + 1L)
  res[1L] <- 1L
  walk(numbers, function(nr) {
    for (i in capacity:nr) {
      res[i + 1L] <<- res[i + 1L] + res[i - nr + 1L] 
    }
  })
  tail(res, 1L)
}
count_sums(puzzle_data, 150)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

This time we need also to keep track about the amount of summands.

```{r get-solution-2}
count_min_sums <- function(numbers, capacity) {
  dp <- rep(Inf, capacity + 1L)
  ways <- rep(0L, capacity + 1L) 
  
  dp[1L] <- 0L
  ways[1L] <- 1L
  walk(numbers, function(nr) {
    for (j in capacity:nr) {
      if (dp[j - nr + 1L] + 1L < dp[j + 1L]) {
        dp[j + 1L] <<- dp[j - nr + 1L] + 1L
        ways[j + 1L] <<- ways[j - nr + 1L]
      } else if (dp[j - nr + 1L] + 1L == dp[j + 1L]) {
        ways[j + 1L] <<- ways[j + 1L] + ways[j - nr + 1L]
      }
    }
  }
  )
  list(min_count = dp[capacity + 1L], min_ways = ways[capacity + 1L])
}
count_min_sums(puzzle_data, 150L)
```
