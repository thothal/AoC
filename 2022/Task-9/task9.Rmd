---
params:
   task_nr: 9
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(tidyr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_split(" ") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("dir", "n")) %>% 
    as_tibble() %>% 
    mutate(n = as.integer(n))
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

```{r get-solution-1}
get_pos <- function(pos, dis) {
  rownames(pos)[apply(pos, 1L, \(r) all(r == dis))]
}

generate_move_table <- function(tail_pos) {
  new_head_pos <- tail_pos[tail_pos[, 1L] != 0 | tail_pos[, 2L] != 0, ]
  res <- matrix(NA_character_, nrow(tail_pos), nrow(new_head_pos),
                dimnames = list(rownames(tail_pos), rownames(new_head_pos)))
  for (tp in rownames(tail_pos)) {
    for (new_hp in rownames(new_head_pos)) {
      if (tp == "SW" && new_hp == "N") browser()
      tail <- tail_pos[tp, ]
      head <- new_head_pos[new_hp, ]
      dis <- tail - head
      pos <-  get_pos(tail_pos, dis)
      if (length(pos) > 0L) {
        res[tp, new_hp] <- pos
      } else if (any(dis == 0L)) {
        res[tp, new_hp] <- get_pos(tail_pos, dis %/% 2L)
      } else if (any(abs(dis) == 2L)) {
        tail_dir <- sign(dis)
        new_tp <- tail + head + tail_dir
        res[tp, new_hp] <- get_pos(tail_pos, new_tp)
      }
    }
  }
  res
}

move_rope <- function(steps, rope_length = 1L) {
  steps <- steps %>% 
    mutate(dir = c(U = "N", R = "E", D = "S", L = "W")[dir] %>% 
             unname())
  pos <- expand_grid(x = -1:1, y = -1:1) %>%
    as.matrix() %>% 
    set_rownames(c("NW", "N", "NE", "W", "C", "E", "SW", "S", "SE")) %>% 
    set_colnames(NULL)
  lkp <- generate_move_table(pos)
  head_pos <- c(0L, 0L) 
  tails_pos <- matrix(0L, rope_length, 2L)
  all_tail_pos <- matrix(0L, 1L, 2L)
  dirs <- rbind(
    N = c(-1L, 0L),
    E = c(0L, 1L),
    S = c(1L, 0L),
    W = c(0L, -1L)
  )
  for (i in seq_len(nrow(steps))) {
    step <- steps %>% 
      slice(i) %>% 
      as.list()
    for (s in seq_len(step$n)) {
      prev_knot_pos_old <- head_pos
      prev_knot_pos_new <- head_pos <- head_pos + dirs[step$dir, ]
      for (knot in seq_len(nrow(tails_pos))) {
        tail_pos <- tails_pos[knot, ]
        rel_pos <- get_pos(pos, tail_pos - prev_knot_pos_old)
        if (any(abs(tail_pos - prev_knot_pos_new) > 1L)) {
          if (i == 2) browser()
          new_pos <- lkp[rel_pos, step$dir]
          prev_knot_pos_old <- tail_pos
          tail_pos <- prev_knot_pos_new + pos[new_pos, ]  
        } else {
          prev_knot_pos_old <- tail_pos
        }
        prev_knot_pos_new <- tail_pos
        tails_pos[knot, ] <- tail_pos
      }
      all_tail_pos <- rbind(all_tail_pos, tails_pos[nrow(tails_pos), ])
    }
    
    print(tails_pos)
  }
  
  all_tail_pos[!duplicated(all_tail_pos), , drop = FALSE] %>% 
    nrow()
}
move_rope(puzzle_data) # 4898 too high

```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For each tree we count the number of smaller trees in the line of sight. We need to add
one in case there is no such tree, because we will always see the tree next to the 
current position (even if it is taller). If there is at least one tree, we counted it
already so we must not add this bonus.


```{r get-solution-2}
get_scenic_score <- function(forrest) {
  dd <- dim(forrest)
  scenic_score <- array(0L, dd)
  for (i in 2:(dd[1L] - 1L)) {
    for (j in 2:(dd[2L] - 1L)) {
      height <- forrest[i, j]
      top <- forrest[(i - 1L):1, j]
      bottom <- forrest[(i + 1L):dd[1L], j]
      left <- forrest[i, (j - 1L):1]
      right <- forrest[i, (j + 1L):dd[2L]]
      n_top <- sum(cumall(height > top)) + (!all(height > top))
      n_bottom <- sum(cumall(height > bottom)) + (!all(height > bottom))
      n_left <- sum(cumall(height > left)) + (!all(height > left))
      n_right <- sum(cumall(height > right)) + (!all(height > right))
      scenic_score[i, j] <- n_top * n_bottom * n_left * n_right
    }
  }
  max(scenic_score)
}

get_scenic_score(puzzle_data)
```
