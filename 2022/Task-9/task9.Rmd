---
params:
   task_nr: 9
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(tidyr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_split(" ") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("dir", "n")) %>% 
    as_tibble() %>% 
    mutate(n = as.integer(n))
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We generate a move lookup table, which returns the delta the tail has to move depending
on where the tail was and in which direction the head is moving. Though the head can move
only vertically and horizontally, we also include diagonal movements, as we will need them
for the second part.

With this lookup table in place, we just need to determine at which position the tail is
before we move and use this position plus the direction of movement to look up the delta
to get the new tail position. We continue until all steps are carried out and count unique
positions of the tail.

```{r get-solution-1}
get_pos <- function(dis) {
  dirs <- c("C", "E", "W", "S", "SE", "SW", "N", "NE", "NW")
  idx <- sum(dis %% 3L * c(3L, 1L)) + 1L
  dirs[idx]
}

generate_move_table <- function(tail_pos) {
  d <- nrow(tail_pos)
  diag <- c("NE", "SE", "SW", "NW")
  opposite <- c(N = "S", S = "N", E = "W", W = "E")
  move_lkp <- array(0L, c(d, d - 1L, 2L), 
                    list(rownames(tail_pos), 
                         setdiff(rownames(tail_pos), "C"),
                         NULL))
  dirs <- rbind(
    N = c(-1L, 0L),
    E = c(0L, 1L),
    S = c(1L, 0L),
    W = c(0, -1L)
  )
  for (d in rownames(tail_pos)) {
    if (d == "C") {
      next
    }
    x <- str_split(d, "") %>% 
      unlist()
    dir <- colSums(dirs[opposite[x], , drop = FALSE])
    ## straight movements
    move_lkp[d, opposite[x], ] <- matrix(dir, length(x), 2L, byrow = TRUE)
    for (di in diag) {
      ## diagonal movements
      y <- str_split(di, "") %>% 
        unlist()
      if (all(x %in% y)) {
        next
      }
      dir <- colSums(dirs[setdiff(y, x), , drop = FALSE])
      move_lkp[d, di, ] <- dir
    }
  }
  move_lkp
}

move_rope <- function(steps, rope_length = 1L) {
  steps <- steps %>% 
    mutate(dir = c(U = "N", R = "E", D = "S", L = "W")[dir] %>% 
             unname())
  pos <- expand_grid(x = -1:1, y = -1:1) %>%
    as.matrix() %>% 
    set_rownames(c("NW", "N", "NE", "W", "C", "E", "SW", "S", "SE")) %>% 
    set_colnames(NULL)
  lkp <- generate_move_table(pos)
  head_pos <- c(0L, 0L) 
  tails_pos <- matrix(0L, rope_length, 2L)
  all_tail_pos <- matrix(0L, 1L, 2L)
  dirs <- rbind(
    N = c(-1L, 0L),
    E = c(0L, 1L),
    S = c(1L, 0L),
    W = c(0L, -1L)
  )
  for (i in seq_len(nrow(steps))) {
    step <- steps %>% 
      slice(i) %>% 
      as.list()
    for (s in seq_len(step$n)) {
      prev_knot_pos_old <- head_pos
      prev_knot_pos_new <- head_pos <- head_pos + dirs[step$dir, ]
      dir <- step$dir
      for (knot in seq_len(nrow(tails_pos))) {
        tail_pos <- tails_pos[knot, ]
        rel_pos <- get_pos(tail_pos - prev_knot_pos_old)
        if (any(abs(tail_pos - prev_knot_pos_new) > 1L)) {
          tail_delta <- lkp[rel_pos, dir, ]
          prev_knot_pos_old <- tail_pos
          prev_knot_pos_new <- tail_pos <- tail_pos + tail_delta
          dir <- get_pos(tail_delta)
          tails_pos[knot, ] <- tail_pos
        } else {
          break
        }
      }
      all_tail_pos <- rbind(all_tail_pos, tails_pos[nrow(tails_pos), ])
    }
    
  }
  all_tail_pos[!duplicated(all_tail_pos), , drop = FALSE] %>% 
    nrow()
}
move_rope(puzzle_data) 

```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

To implement the movement of longer ropes, we just have to move each knot one after the 
other. Now knots can also move diagonally, which we need to consider to get the direction
for the next knot.

```{r get-solution-2}
move_rope(puzzle_data, 9L)
