---
params:
   task_nr: 20
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(R6)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_extract_all("-?\\d+") %>% 
    as.integer()
           
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We use a linked list as a data structure. Forst all numbers are mapped to their original
position in the array `lkp`. Then, `circle[i]` stores the number index of the number 
following `lkp[i]`. Consider for instance the following sequence:
$$
5, 1, -3
$$
Then we set `lkp[1] = 5, lkp[2] = 1` and `lkp[3] = -3`. `circle[1]` stores the element 
index **after** `lkp[1]` which is `2`, i.e. `circle[1] = 2, circle[2] = 3, circle[3] = 1`.
Moving any element requires than the following operations:

1. Determine the index `k` in `lkp` of this element (*N.B.* since we are looping over all 
elements in `lkp` anyway this is trivially the iteration counter).
1. Following the circle to get it's new successor via nesting circle lookups as needed. 
For instance, if we want to move it 3 positions we look up `circle[circle[circle[k]]]`.
1. Then we need to re-assign the pointers: `circle[k] = circle[circle[circle[k]]]` and
`circle


```{r get-solution-1}
DoubleLinkedList <- R6Class(
  "DoubleLinkedList",
  private = list(
    n = integer(0L),
    val = NULL,
    prv = integer(0L),
    nxt = integer(0L),
    head = integer(0L)
  )
)

DoubleLinkedList$set(
  "public",
  "initialize",
  function(x) {
    n <- length(x)
    private$n <- n
    private$val <- x
    private$prv <- c(n, 1:(n - 1L))
    private$nxt <- c(2:n, 1L)
    private$head <- 1L
  }
)

DoubleLinkedList$set(
  "public",
  "print",
  function(...) {
    out <- vector(mode = typeof(private$val), length = private$n)
    k <- private$head
    for (j in seq_len(private$n)) {
      out[j] <- private$val[k]
      k <- private$nxt[k]
    }
    print(out)
    invisible(self)
  }
)

DoubleLinkedList$set(
  "public",
  "move",
  function(value) {
    i <- which(private$val == value)
    shift <- value
    if (shift == 0L) {
      return(self)
    }
    k <- abs(as.integer(shift)) %% (private$n - 1L)
    if (k == 0L) {
      return(invisible(self))
    }
    nb <- private$detach_node(i)
    a <- nb$a
    b <- nb$b
    if (shift > 0L) {
      target <- private$advance(b, k - 1L)
      private$insert_after(i, target)
    } else {
      target <- private$retreat(a, k)
      private$insert_after(i, target)
    }
    invisible(self)
  }
)

DoubleLinkedList$set(
  "private",
  "advance",
  function(i, k) {
    if (k <= 0L) {
      return(i)
    }
    for (. in seq_len(k)) {
      i <- private$nxt[i]
    }
    i
  }
)

DoubleLinkedList$set(
  "private",
  "retreat",
  function(i, k) {
    if (k <= 0L) {
      return(i)
    }
    for (. in seq_len(k)) {
      i <- private$prv[i]
    }
    i
  }
)

DoubleLinkedList$set(
  "private",
  "detach_node",
  function(i) {
    a <- private$prv[i]
    b <- private$nxt[i]
    private$nxt[a] <- b
    private$prv[b] <- a
    if (env$head == i) {
      env$head <- b 
    }
    list(a = a, b = b)
  }
)

DoubleLinkedList$set(
  "private",
  "insert_after",
  function(i, t) {
    u <- private$nxt[t]
    private$nxt[t] <- i
    private$prv[i] <- t
    private$nxt[i] <- u
    private$prv[u] <- i  
  }
)




mix_numbers <- function(x, nr_rounds) {
  nrs <- build_dll(x)
  for (j in seq_len(nr_rounds)) {
    i <- (j - 1) %% length(x) + 1L
    nrs <- move_by_value(nrs, x[i])
  }
  as_vector(nrs)
}

mix_numbers(ex, 3)

```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part we can use the same fast `C++` algorithm, with a larger round number.

```{r get-solution-2, cache = TRUE}
multiply_geode_amounts <- function(bps) {
  imap_int(bps[1:3], ~ solve_blueprint(32L, .x)) %>% 
    prod()
}

multiply_geode_amounts(puzzle_data)
```

# R Legacy Solution

```{r legacy-code, eval = FALSE}
solve_blueprint <- function(bp, time_limit) {
  robots <- c(ore = 1L, clay = 0L, obsidian = 0L, geode = 0L)
  resources <- c(ore = 0L, clay = 0L, obsidian = 0L, geode = 0L)
  max_geode <- 0L
  memo <- new.env(parent = emptyenv())
  max_cost <- do.call(rbind, bp) %>% 
    apply(2L, max)
  max_cost["geode"] <- Inf
  get_upper_bound <- function(time, robots, resources) {
    resources["geode"] + # amount of geode we have so far
      robots["geode"] * time + # amount of geode the existing robots will produce
      time * (time - 1L) / 2L # max output if we could build a geode robot eahc turn
  }
  
  cap_resources <- function(resources, time, max_cost) {
    capped <- pmin(resources[names(max_cost)], max_cost * time)
    c(capped, resources["geode"])
  }
  rec <- 0L
  
  dfs <- function(time, robots, resources) {
    if (time == 0L) {
      max_geode <<- max(max_geode, resources["geode"])
      return(resources["geode"])
    }
    if (get_upper_bound(time, robots, resources) <= max_geode) {
      return(0L)
    }
    
    capped_resources <- cap_resources(resources, time, max_cost)
    key <- paste(time, paste(robots, collapse = ","), 
                 paste(capped_resources, collapse = ","),
                 sep = "|")
    if (exists(key, memo, inherits = FALSE)) {
      return(memo[[key]])
    }
    max_local <- 0L
    produced <- resources + robots
    robot_types <- rev(names(robots))
    for (robot_type in robot_types) {
      if (robot_type != "geode" && robots[robot_type] >= max_cost[robot_type]) {
        next
      }
      robot_cost <- bp[[robot_type]]
      if (all(resources[-4L] >= robot_cost)) {
        new_resources <- produced - c(robot_cost, 0L)
        new_robots <- robots
        new_robots[robot_type] <- new_robots[robot_type] + 1L
        if (robot_type == "geode") {
          max_local <- max(max_local, Recall(time - 1L, new_robots, new_resources))
          memo[[key]] <<- max_local
          return(max_local)
        }
        max_local <- max(
          max_local,
          Recall(time - 1L, new_robots, new_resources)
        )
      }  
    }
    max_local <- max(
      max_local,
      Recall(time - 1L, robots, produced)
    )
    memo[[key]] <<- max_local
    return(max_local)
  }
  res <- dfs(time_limit, robots, resources)
  res
}

```

