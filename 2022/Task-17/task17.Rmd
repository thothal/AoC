---
params:
   task_nr: 17
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_split("") %>% 
    extract2(1L)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution


```{r get-solution-1}
print.cave <- function(x, rock_idx = NULL, rock = NULL, ...) {
  cave <- if_else(c(x), "#", ".")
  dim(cave) <- dim(x)
  if (!is.null(rock_idx)) {
    rock_idx <- rock_idx[c(rock), , drop = FALSE]
    cave[rock_idx] <- "@"  
  }
  bottom <- rep(c("+", "-", "+"), c(1L, ncol(x), 1L))
  cave <- cbind("|", cave, "|") %>% 
    rbind(bottom)
  apply(cave, 1L, paste, collapse = "") %>% 
    paste(collapse = "\n") %>% 
    cat("\n")
  invisible(x)
}

simulate_rock_tetris <- function(jet, nr_rounds) {
  rocks <- list(
    matrix(TRUE, 1L, 4L),
    matrix(c(FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE), 3L, 3L),
    matrix(c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE), 3L, 3L),
    matrix(TRUE, 4L, 1L),
    matrix(TRUE, 2L, 2L)
  )
  ## highest tower is if all I shaped rocks land on top of each other
  ## each rock needs at most 4 tiles and it starts 3 tiles above the currently highest
  ## tile
  bottom <- (nr_rounds + 1L) * 4L + 3L
  cave <- matrix(FALSE, (nr_rounds + 1L) * 4L + 3L, 7L)
  class(cave) <- "cave"
  dirs <- rbind(
    ">" = c(0L, 1L),
    "<" = c(0L, -1L)
  )
  cur_rock <- 1L
  get_idx <- function(pos, rock) {
    r_idx <- row(rock) - nrow(rock)
    c_idx <- col(rock) - 1L
    cbind(pos[1L] + c(r_idx),
          pos[2L] + c(c_idx))
  }
  jet_pos <- 1L
  for (rnd in seq_len(nr_rounds)) {
    rock <- rocks[[cur_rock]]
    rows_n <- rowSums(cave)
    if (all(rows_n == 0L)) {
      height <- bottom
    } else {
      height <- which(rows_n > 0L) %>% 
        min() %>% 
        subtract(1L)
    }
    corner_pos <- cbind(height - 3L, 3L)
    at_rest <- FALSE
    while (!at_rest) {
      ## 1. Move horizontally
      cur_rock_pos <- get_idx(corner_pos, rock)
      next_rock_pos <- cur_rock_pos + matrix(dirs[jet[jet_pos], ], nrow(cur_rock_pos), 2L, byrow = TRUE)
        sweep(cur_rock_pos, 2L, dirs[jet[jet_pos], , drop = FALSE], `+`)
      if (all(next_rock_pos[, 2L] >= 1L & next_rock_pos[, 2L] <= ncol(cave))) {
        ## rock is in bounds
        if (!any(cave[next_rock_pos] & rock)) {
          ## new position is free
          cur_rock_pos <- next_rock_pos
          corner_pos <- corner_pos + dirs[jet[jet_pos], , drop = FALSE]
        }
      }
      ## 2. move vertically
      next_rock_pos <- cur_rock_pos + cbind(1L, rep(0L, nrow(cur_rock_pos)))
      at_rest <- TRUE
      if (all(next_rock_pos[, 1L] <= nrow(cave))) {
        ## rock is in bounds
        if (!any(cave[next_rock_pos] & rock)) {
          ## new position is free
          cur_rock_pos <- next_rock_pos
          corner_pos <- corner_pos + cbind(1L, 0L)
          at_rest <- FALSE
        }
      }
      jet_pos <- (jet_pos %% length(jet)) + 1L
    }
    cave[cur_rock_pos] <- rock
    cur_rock <- (cur_rock %% length(rocks)) + 1L
  }
  rows_n <- rowSums(cave)
  last_row <- which(rows_n > 0L) %>% 
        min()
  nrow(cave) - last_row + 1L
}

simulate_rock_tetris(puzzle_data, 2022L) # 3168 too high

```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution


```{r get-solution-2}

```