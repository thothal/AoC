---
params:
   task_nr: 18
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  res <- text_block %>% 
    str_split(",") %>% 
    do.call(rbind, .) %>% 
    set_colnames(letters[24:26])
  storage.mode(res) <- "integer"
  res
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution




```{r get-solution-1}
get_cube_grid <- function(coords) {
  max_d <- apply(coords, 2L, max)
  grid <- array(FALSE, max_d)
  grid[coords] <- TRUE
  idx <- which(grid, arr.ind = TRUE)
  dirs <- expand.grid(x = -1:1, y = -1:1, z = -1:1) %>% 
    filter(x != 0L | y != 0 | z != 0L) %>% 
    as.matrix()
  dd <- dim(grid)
  nbs <- array(FALSE, dd)
  for (i in seq_len(nrow(idx))) {
    nbs <- t(t(dirs) + idx[i])
    nbs <- nbs[nbs[, 1L] >= 1L & nbs[, 1L] <= dd[1L] &
                 nbs[, 2L] >= 1L & nbs[, 2L] <= dd[2L] &
                 nbs[, 3L] >= 1L & nbs[, 3L] <= dd[3L]]
  }
}
get_cube_grid(ex)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part brute-force is out-of question, so we need to find recurring patterns.
At each iteration we look at the top 4 rows and store them together with the next rock and
jet. If at any stage we get a state whihc we have seen before, i.e. same surface same next 
rock and sam enext jet we can fast forward by calculating the cycle length and gain.

```{r get-solution-2}
calculate_height <- function(jet, nr_rounds) {
  rocks <- list(
    matrix(TRUE, 1L, 4L),
    matrix(c(FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE), 3L, 3L),
    matrix(c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE), 3L, 3L),
    matrix(TRUE, 4L, 1L),
    matrix(TRUE, 2L, 2L)
  )
  hash <- new.env(parent = emptyenv())
  ## each round we drop a rock of height 1 - 4
  ## each 5 rounds we have dropped all rocks with a total of 13 height
  ## that is a conservative estimation of the maximum height is 
  ## ceiling(13 * nr_rounds / 5) + 3L 
  
  bottom <- ceiling(13L * 10000L / 5L) + 3L
  cave <- matrix(FALSE, bottom, 7L)
  class(cave) <- "cave"
  dirs <- rbind(
    ">" = c(0L, 1L),
    "<" = c(0L, -1L)
  )
  cur_rock <- 1L
  get_idx <- function(pos, rock) {
    r_idx <- row(rock) - nrow(rock)
    c_idx <- col(rock) - 1L
    cbind(pos[1L] + c(r_idx),
          pos[2L] + c(c_idx))
  }
  jet_pos <- 1L
  added_height <- 0L
  rnd <- 1L
  surface_size <- 4L
  while (rnd <= nr_rounds) {
    rock <- rocks[[cur_rock]]
    rows_n <- rowSums(cave)
    if (all(rows_n == 0L)) {
      height <- bottom
    } else {
      height <- which(rows_n > 0L) %>% 
        min() %>% 
        subtract(1L)
    }
    corner_pos <- cbind(height - 3L, 3L)
    at_rest <- FALSE
    horizontal <- vertical <- 0L
    while (!at_rest) {
      ## 1. Move horizontally
      cur_rock_pos <- get_idx(corner_pos, rock)
      next_rock_pos <- sweep(cur_rock_pos, 2L, dirs[jet[jet_pos], , drop = FALSE], `+`)
      if (all(next_rock_pos[, 2L] >= 1L & next_rock_pos[, 2L] <= ncol(cave))) {
        ## rock is in bounds
        if (!any(cave[next_rock_pos] & rock)) {
          ## new position is free
          cur_rock_pos <- next_rock_pos
          corner_pos <- corner_pos + dirs[jet[jet_pos], , drop = FALSE]
          horizontal <- horizontal + (jet[jet_pos] == ">")
        }
      }
      ## 2. move vertically
      next_rock_pos <- sweep(cur_rock_pos, 2L, cbind(1L, 0L), `+`)
      at_rest <- TRUE
      if (all(next_rock_pos[, 1L] <= nrow(cave))) {
        ## rock is in bounds
        if (!any(cave[next_rock_pos] & rock)) {
          ## new position is free
          cur_rock_pos <- next_rock_pos
          corner_pos <- corner_pos + cbind(1L, 0L)
          at_rest <- FALSE
          vertical <- vertical + 1L 
        }
      }
      jet_pos <- (jet_pos %% length(jet)) + 1L
    }
    cave[cur_rock_pos] <- cave[cur_rock_pos] | rock
    rows_n <- rowSums(cave)
    last_row <- which(rows_n > 0L) %>% 
      min()
    cur_rock <- (cur_rock %% length(rocks)) + 1L
    rnd <- rnd + 1L
    if (last_row < bottom - surface_size) {
      top_rows <- cave[last_row:(last_row + surface_size), ]
      key <- digest(list(top_rows, cur_rock, jet_pos))
      prev <- hash[[key]]
      if (!is.null(prev)) {
        rnd_prev <- prev$rnd
        h_prev <- prev$height
        cur_h <- bottom - last_row + 1L + added_height
        cycle_len  <- rnd - rnd_prev 
        cycle_gain <- (cur_h - h_prev)
        remain  <- nr_rounds - rnd
        if (cycle_len > 0L && remain >= cycle_len) {
          cycles <- remain %/% cycle_len
          added_height <- added_height + cycles * cycle_gain
          rnd <- rnd + cycles * cycle_len
          ## empty hash
          hash <- new.env(parent = emptyenv())
        }
      } else {
        hash[[key]] <- list(rnd = rnd, height = bottom - last_row + 1L + added_height)
      }
    }

  }
  rows_n <- rowSums(cave)
  last_row <- which(rows_n > 0L) %>% 
    min()
  height <- bottom - last_row + 1L
  as.integer64(height + added_height)
}

calculate_height(puzzle_data, 1000000000000)

```