---
params:
   task_nr: 10
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(tidyr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_split(" ") %>% 
    map(~ c(.x, NA_character_)[1:2]) %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("op", "arg")) %>% 
    as_tibble() %>% 
    mutate(arg = as.integer(arg))
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We add a counter which indicates the cycle as well as the cumulative sum (where we add 
`1` for the starting value of the register). Then we complete the cycles, that is fill in 
missing cycles between operations and fill the cumulative sum down.

The cumulative sum represents the value at the **end** of the cycle, to get the value at
the start, we need to look at the value just before. Eventually we sum all these values
to get the signal strength.

```{r get-solution-1}
get_signal <- function(ops, cycles) {
  signals <- ops %>% 
    mutate(cycle = cumsum(if_else(op == "noop", 1L, 2L)),
           cs = cumsum(coalesce(arg, 0L)) + 1L) %>% 
    complete(cycle = full_seq(cycle, 1)) %>% 
    mutate(cycle = as.integer(cycle)) %>% 
    fill(cs)
  
  signals %>% 
    filter(cycle %in% (cycles - 1L) ) %>% 
    summarize(signal = sum((cycle + 1L) * cs)) %>%
    pull(signal)
}

get_signal(puzzle_data, c(20L, 60L, 100L, 140L, 180L, 220L))
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

We fill the operations as before. When there is an `addx` operation, it means that the
operation just finished at this moment. We keep track of the CRT sprite position and move
it accordingly. When one of the three the sprite positions coincide with the cycle counter
we draw the pixel. At cycle times 41, 81, 121, 161 and 201 we have to move the row. The 
row index is also needed to amke the comparison with the cycle counter.

*N.B.* As matrices can be indexed by a single continuous index in column-major order, we
use a tansposed matrix in the beginning to be able to index simply by the cycle.

```{r get-solution-2, comment = ""}
render_crt <- function(ops) {
  crt <- matrix(".", 40L, 6L)
  cycle <- 1L
  ops <- ops %>% 
    mutate(cycle = cumsum(if_else(op == "noop", 1L, 2L))) %>% 
    complete(cycle = full_seq(c(1L, cycle), 1L)) %>% 
    mutate(cycle = as.integer(cycle),
           op = coalesce(op, "noop"))
  n <- nrow(ops)
  crt_col <- 1L
  crt_row <- 1L
  x <- 1L
  while (cycle <= n) {
    op <- ops %>% 
      slice(!!cycle) %>% 
      as.list()
    if (cycle %in% ((crt_row - 1L) * 40L + crt_col + 0:2)) {
      crt[cycle] <- "\U2588"
    } else {
      crt[cycle] <- " "
    }
    if (op$op == "addx") {
      x <- x + op$arg
      crt_col <- x
    }
    cycle <- cycle + 1L
    if (cycle %% 40L == 1L) {
      crt_row <- crt_row + 1L
    }
  }
  t(crt) %>% 
    apply(1L, paste, collapse = "") %>% 
    paste(collapse= "\n") %>% 
    cat()
}

render_crt(puzzle_data) ## RUAKHBEK
```