---
params:
   task_nr: 15
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(tidyr)
library(bit64)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_extract_all("-?\\d+") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("x", "y", "b_x", "b_y")) %>% 
    as_tibble() %>% 
    mutate(across(everything(), as.integer))
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

For each sensor, we calculate the Manhatten distance to its closest beacon. Then, for the 
target row, we mark those fields which are in range of any of the sensory and cound them.

```{r get-solution-1}
count_dead_fields <- function(sensors, target_row) {
  sensors <- sensors %>% 
    mutate(
      dis = abs(x - b_x) + abs(y - b_y),
      dis_target = dis - abs(target_row - y)
    ) %>% 
    filter(dis_target >= 0) %>% 
    mutate(
      x_min = x - dis_target,
      x_max = x + dis_target
    ) %>% 
    arrange(x_min, x_max)

  intervals <- sensors %>% 
    select(x_min:x_max) %>% 
    apply(1L, c, simplify = FALSE)
  
  intervals <- reduce(intervals, function(acc, cur) {
    if (length(acc) == 0L) {
      return(list(cur))
    }
    last <- acc[[length(acc)]]
    if (cur[1] <= last[2] + 1L) {
      acc[[length(acc)]][2] <- max(last[2], cur[2])
      acc
    } else {
      c(acc, list(cur))
    }
  }, .init = list())
  beacons_in_range <- sensors %>% 
    filter(b_y == target_row) %>% 
    distinct(b_x, b_y) %>% 
    rowwise() %>% 
    mutate(in_range = any(vapply(intervals, \(iv) between(b_x, iv[1], iv[2]), 
                                 logical(1L)))) %>% 
    filter(in_range) %>% 
    nrow()
  intervals  %>%
    map_int(~ diff(range(.x)) + 1L) %>%
    sum() %>% 
    subtract(beacons_in_range)
}
count_dead_fields(puzzle_data, 2000000L) 



```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we observe that around each sender there is a diamond shaped area 
where there is no beacon. Let $r$ be the radius of such a diamond (i.e. the  
manhatten distance from beacon to sender), then all points on the border satisfy the
equation
$$
|x-s_x| + |y-s_y| = r
$$
A free spot must be *outside* this region. As there is only *one* free spot, it
must be on the line with radius $r + 1$, thus we need to solve:
$$
|x-s_x| + |y-s_y| = r + 1
$$
By eliminating the absolute values, we can rewrite the condition as the following four 
equations:
$$
\begin{align}
x - s_x + y - s_y &= r +1\\
x+ y &= \underbrace{(s_x + s_y) + (r+1)}_{=:A^+}\\
x - s_x - (y - s_y) &= r +1\\
x- y &= \underbrace{(s_x - s_y) + (r+1)}_{=:B^+}\\
-(x - s_x) + y - s_y &= r +1\\
x- y &= \underbrace{(s_x - s_y) - (r+1)}_{=:B^-}\\
-(x - s_x) - (y - s_y) &= r +1\\
x+ y &= \underbrace{(s_x + s_y) - (r+1)}_{=:A^-}
\end{align}
$$
That is, we calculate $A^+$, $A^-$, $B^+$ and $B^-$ for each sensor and intersect each A
line with each B line determined by these constants for each sensor pair $S_i$ and $S_j$ 
with $i\neq j$. If we find an integer point that lies outside the range of all sensors, 
we have found the solution.

```{r get-solution-2}
get_tuning_freqeuncy <- function(sensors, limit = c(0L, 4000000L)) {
  sensors <- sensors %>% 
    mutate(
      x,
      y,
      r = abs(x - b_x) + abs(y - b_y) + 1L,
      A0 = x + y + r,
      A1 = x + y - r,
      B0 = x - y + r,
      B1 = x - y - r,
      .keep = "none") %>% 
    mutate(id = 1:n(), .before = 1L)
  intersections <- inner_join(sensors, sensors, join_by(id < id)) %>% 
    rowwise() %>% 
    mutate(
      A = list(c(A0.x, A1.x)),
      B = list(c(B0.y, B1.y)),
      id.x, 
      id.y,
      .keep = "none"
    ) %>% 
    mutate(AB = list(expand.grid(A = A, B = B)),
           .keep = "unused") %>% 
    unnest(AB)
  
  intersections <- intersections %>%
    mutate(
      x = (A + B) / 2,
      y = (A - B) / 2
    ) %>% 
    filter(x == floor(x), y == floor(y)) %>% 
    mutate(x = as.integer(x),
           y = as.integer(y)) %>% 
    filter(between(x, limit[1L], limit[2L]),
           between(y, limit[1L], limit[2L]))
  
  is_covered <- function(x0, y0) {
    sensors %>% 
      mutate(dist = abs(x - x0) + abs(y - y0),
             is_covered = dist <= r - 1L) %>% 
      summarize(is_covered = any(is_covered)) %>% 
      pull(is_covered)
  }
  
  intersections %>% 
    rowwise() %>% 
    mutate(is_covered = is_covered(x, y)) %>% 
    filter(!is_covered) %>% 
    distinct(x, y) %>% 
    summarize(tuning_freqeuncy = as.integer64(x) * 4000000L + as.integer64(y)) %>% 
    pull(tuning_freqeuncy)
}

get_tuning_freqeuncy(puzzle_data)
```