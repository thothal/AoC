---
params:
   task_nr: 13
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block <- text_block[vapply(text_block, nzchar, logical(1L))]
  nested <- text_block %>% 
    str_replace_all("[\\[\\]]",  \(r) if_else(r == "[", "list(", ")"))
  map((seq_len(length(nested) / 2L) - 1L) * 2L + 1L, 
      ~ list(left = eval(parse(text = nested[[.x]])),
             right = eval(parse(text = nested[[.x + 1L]]))))
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We write a recursive function, which compares the elements. If both elements are numbers,
we can compare them directly. If one the elements is a list and the other is a number, we
need to embed it into a list. Then, we iterate through the list (unsing the smaller size 
as upper limit for the loop) and exit early if we have a clear decision. If all
comparisons are undefined (equal elements), we use the length of the list as tie breaker.

```{r get-solution-1}
compare_pair <- function(left, right) {
  is_number_left <- !is.list(left)
  is_number_right <- !is.list(right)
  if (is_number_left && is_number_right) {
    return(sign(right - left))
  }
  if (is_number_left && !is_number_right) {
    left <- list(left)
  } else if (!is_number_left && is_number_right) {
    right <- list(right)
  }
  
  for (i in seq_len(min(length(left), length(right)))) {
    res <- Recall(left[[i]], right[[i]])
    if (res != 0L) {
      return(res)
    }
  }
  ## no decision yet => make comparison based on length of left & right
  return(sign(length(right) - length(left)))
}

get_correct_indices <- function(pairs) {
  idx <- map_int(pairs, ~ do.call(compare_pair, .x)) %>% 
    equals(1L)
  sum(which(idx))
}

get_correct_indices(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we implement a merge sort based on the comparison function defined
before. and look for the indices of the marker elements.

```{r get-solution-2}
merge_sort <- function(x) {
  n <- length(x)
  if (n <= 1L) {
    return(x)
  }

  mid <- n %/% 2
  left  <- merge_sort(x[1:mid])
  right <- merge_sort(x[(mid + 1):n])
  merge(left, right)
}

merge <- function(left, right) {
  res <- list()
  i <- j <- 1L

  while (i <= length(left) && j <= length(right)) {
    if (compare_pair(left[[i]], right[[j]]) == 1L) {
      res[[length(res) + 1L]] <- left[[i]]
      i <- i + 1L
    } else {
      res[[length(res) + 1L]] <- right[[j]]
      j <- j + 1L
    }
  }

  if (i <= length(left)) {
    res <- c(res, left[i:length(left)])
  }
  if (j <= length(right)) {
    res <- c(res, right[j:length(right)])
  }
  res
}

get_decoder_value <- function(elements) {
  m1 <- list(list(2))
  m2 <- list(list(6))
  elements <- unlist(elements, FALSE, FALSE)
  sorted <- merge_sort(c(list(m1), list(m2), elements))
  pos1 <- which(vapply(sorted, identical, logical(1L), m1))
  pos2 <- which(vapply(sorted, identical, logical(1L), m2))
  pos1 * pos2
}

get_decoder_value(puzzle_data)

```