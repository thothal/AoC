---
params:
   task_nr: 19
   year: 2022
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: TRUE
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```

```{js cpp-highlighter, file = "Prism_CPP.js", echo = FALSE}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_extract_all("\\d+") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("id", "ore_cost_ore", "clay_cost_ore", "obsidian_cost_ore", 
                   "obsidian_cost_clay", "geode_cost_ore", "geode_cost_obsidian")) %>% 
    as_tibble() %>% 
    mutate(across(everything(), as.integer)) %>% 
    mutate(costs = list(
      list(ore = c(ore = ore_cost_ore, clay = 0L, obsidian = 0L),
                        clay = c(ore = clay_cost_ore, clay = 0L, obsidian = 0L),
                        obsidian = c(ore = obsidian_cost_ore, clay = obsidian_cost_clay,
                                     obsidian = 0L),
                        geode = c(ore = geode_cost_ore, clay = 0L, 
                                  obsidian = geode_cost_obsidian))
      ),
      .by = id) %>% 
    pull(costs)
           
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We solve this puzzle by using a DFS. However, since the search space will grow 
exponentially we have to use some smart pruning ideas:

1. An upper bound for the number of geodes can be found by theoretically building a geode
robot for each of the remaining rounds. The we would produce the number of remaining 
rounds times the number of geode robots plus `round * (round - 1) / 2` as we would produce
one robot each round, that is `1 + 2 + ... +  round` new geodes, for which we can use
the formula Gauss already found.
1. We use Memoization to remember seen states. A state for which we have more of resources
than maximum cost times the rounds is useless (no need to produce more resources than we 
can eventually spend), thus we regard states equivalent if any reosurce is larger than the
amount needed.
1. If we can produce a geode robot we do it right away as it will always be better.
1. There is no need to build any robot other than geode cracking if we have already as 
many as the highest expenses are per mineral as this would lead to a unnecessary stock
of minerals.

We built first an `R` algorithm, which is however too slow (it can be found in the
appendix). To speed up we used the following `C++` implementation for a massive speed 
gain:

```{Rcpp cpp-algorithm, file = "robots.cpp", cache = TRUE}
```

```{r get-solution-1}
sum_quality_levels <- function(bps) {
  imap_int(bps, ~ .y * solve_blueprint(24L, .x)) %>% 
    sum()
}

sum_quality_levels(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part we can use the same fast `C++` algorithm, with a larger round number.

```{r get-solution-2, cache = TRUE}
multiply_geode_amounts <- function(bps) {
  imap_int(bps[1:3], ~ solve_blueprint(32L, .x)) %>% 
    prod()
}

multiply_geode_amounts(puzzle_data)
```

# R Legacy Solution

```{r legacy-code, eval = FALSE}
solve_blueprint <- function(bp, time_limit) {
  robots <- c(ore = 1L, clay = 0L, obsidian = 0L, geode = 0L)
  resources <- c(ore = 0L, clay = 0L, obsidian = 0L, geode = 0L)
  max_geode <- 0L
  memo <- new.env(parent = emptyenv())
  max_cost <- do.call(rbind, bp) %>% 
    apply(2L, max)
  max_cost["geode"] <- Inf
  get_upper_bound <- function(time, robots, resources) {
    resources["geode"] + # amount of geode we have so far
      robots["geode"] * time + # amount of geode the existing robots will produce
      time * (time - 1L) / 2L # max output if we could build a geode robot eahc turn
  }
  
  cap_resources <- function(resources, time, max_cost) {
    capped <- pmin(resources[names(max_cost)], max_cost * time)
    c(capped, resources["geode"])
  }
  rec <- 0L
  
  dfs <- function(time, robots, resources) {
    if (time == 0L) {
      max_geode <<- max(max_geode, resources["geode"])
      return(resources["geode"])
    }
    if (get_upper_bound(time, robots, resources) <= max_geode) {
      return(0L)
    }
    
    capped_resources <- cap_resources(resources, time, max_cost)
    key <- paste(time, paste(robots, collapse = ","), 
                 paste(capped_resources, collapse = ","),
                 sep = "|")
    if (exists(key, memo, inherits = FALSE)) {
      return(memo[[key]])
    }
    max_local <- 0L
    produced <- resources + robots
    robot_types <- rev(names(robots))
    for (robot_type in robot_types) {
      if (robot_type != "geode" && robots[robot_type] >= max_cost[robot_type]) {
        next
      }
      robot_cost <- bp[[robot_type]]
      if (all(resources[-4L] >= robot_cost)) {
        new_resources <- produced - c(robot_cost, 0L)
        new_robots <- robots
        new_robots[robot_type] <- new_robots[robot_type] + 1L
        if (robot_type == "geode") {
          max_local <- max(max_local, Recall(time - 1L, new_robots, new_resources))
          memo[[key]] <<- max_local
          return(max_local)
        }
        max_local <- max(
          max_local,
          Recall(time - 1L, new_robots, new_resources)
        )
      }  
    }
    max_local <- max(
      max_local,
      Recall(time - 1L, robots, produced)
    )
    memo[[key]] <<- max_local
    return(max_local)
  }
  res <- dfs(time_limit, robots, resources)
  res
}

```

