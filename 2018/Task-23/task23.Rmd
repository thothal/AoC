---
params:
   task_nr: 23
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}

```

```{js cpp-highlighter, file = "Prism_CPP.js", echo = FALSE}
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_extract_all("-?\\d+") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("x", "y", "z", "r")) %>% 
    as_tibble() %>% 
    mutate(across(x:r, as.integer))
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
example_data <- list(
  tibble(
    x = c(0L, 1L, 4L, 0L, 0L, 0L, 1L, 1L, 1L), 
    y = c(0L, 0L, 0L, 2L, 5L, 0L, 1L, 1L, 3L), 
    z = c(0L, 0L, 0L, 0L, 0L, 3L, 1L, 2L, 1L), 
    r = c(4L, 1L, 3L, 1L, 3L, 1L, 1L, 1L, 1L)
  ),
  tibble(x = c(10L, 12L, 16L, 14L, 50L, 10L), 
         y = c(12L, 14L, 12L, 14L, 50L, 10L), 
         z = c(12L, 12L, 12L, 14L, 50L, 10L), 
         r = c(2L, 2L, 4L, 6L, 200L, 5L)))[[2L]]
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

The first part is straight forward:
1. Sort the nanobots by their radius.
1. Get the distance from each nanobot form the most powerful nanobot.
1. Count how many nanobots are within the range of the first nanobot.

```{r get-solution-1}
count_nanobots <- function(bots = puzzle_data) {
  bots <- bots %>% 
    arrange(desc(r)) %>% 
    as.matrix()
  ref <- bots[1L, , drop = TRUE] 
  dis <- sweep(bots[, -4L], 2, ref[-4L], function(pos, ref) abs(pos - ref)) %>% 
    rowSums()
  sum(dis <= ref[4L])
}
count_nanobots(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

```{r set-grid-params, echo = FALSE}
coarse_step_size <- 10L
fine_grid <- 50L
```


For the second part we fall back to C++ to be faster. The algorithm follows this idea:

1. First transform the coordinates of each cube to be parallel to the exes.
1. Then create a vector of all coordinates on the border of each cube. As we have now
axes parallel cubes it is guaranteed that the best point must be on the border (as we are
looking for the point closest to the origin).
1. As there are too many combinations of border points, we sample from those using a
step size of `r coarse_step_size` and find the point which intersects with the most
cubes as a first approximation.
1. Finally, we look in the neighborhood of this first approximation using a diameter of
`r fine_grid`. For each point in this cube, we re-calculate the coverage, and if it is
better than the first approximation we update the results accordingly.
1. Eventually we return the sum of the coordinates of this point which corresponds to the
Manhattan distance from the origin.


```{Rcpp cpp-algorithm, file = "nanobots.cpp", cache = TRUE}
```

```{r get-solution-2, cache = TRUE}
<<set-grid-params>>
sum(count_nanobots(as.matrix(puzzle_data), coarse_step_size, fine_grid)$pos)
```
