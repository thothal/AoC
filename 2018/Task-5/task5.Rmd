---
params:
   task_nr: 5
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_split("") %>% 
    extract2(1L)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
example_data <- parse_puzzle_data()
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We work with the ascii representation of the characters, to speed up the algorithm as much
as possible. We build a stack of the ascii codes and keep track of the top position. If
the top position is larger than zero (i.e. there is an element on the stack) and it is
matching (capital letters and small letters are exactly 32 positions apart in the ascii 
alphabet) we reduce the top posiiton by one, that is we look at the previous element on 
the stack. If this is not the case we advance the top position by one and push the current
ascii code on the stack. The final top position determines the length of the reduced 
polymer.

```{r get-solution-1}
count_remaining_units <- function(polymer = puzzle_data) {
  codes <- paste(polymer, collapse = "") %>% 
    utf8ToInt()
  
  n <- length(codes)
  stack <- integer(n)
  top <- 0L
  
  for (code in codes) {
    if (top > 0L && abs(code - stack[top]) == 32L) {
      top <- top - 1L
    } else {
      top <- top + 1L
      stack[top] <- code
    }
  }
  top
}

count_remaining_units(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

With the reasonably fast implementation of the first reducing algorithm, we can afford to
brute force the removal of letters this time. Thus, we remove all occurrences of one unit
in both polarities and calculate the length of the resulting polymer and return the 
minimal length.

```{r get-solution-2}
count_remaining_units_fixed <- function(polymer = puzzle_data) {
  units <- puzzle_data %>% 
    tolower() %>% 
    unique() 
  lengths <- vapply(units, function(unit) {
    mask <- tolower(polymer) != unit
    count_remaining_units(polymer[mask])
  }, integer(1L))
  min(lengths)
}

count_remaining_units_fixed(puzzle_data)
```
