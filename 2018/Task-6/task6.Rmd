---
params:
   task_nr: 6
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  res <- text_block %>% 
    str_split(", ") %>% 
    do.call(rbind, .)
  storage.mode(res) <- "integer"
  res
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
example_data <- parse_puzzle_data()
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We construct a grid by embedding the coordinates into a suitable matrix, where we add a 
row or a column to each of the 4 sides. Then we label each point with the id of the 
closest coordinate (iif unique) in the input. Finally, we remove all coordinates which 
spill to the border of the matrix (these would continue ad infinitum) and for each 
of the remaining ids we count the number of fields they are occupying.

```{r get-solution-1}
embed_positions <- function(coords = puzzle_data) {
  dims <- c(
    max(coords[, 1L]) + 2L, ## add rows on bottom and end of grid
    max(coords[, 2L]) + 2L  ## add columns on left and right of grid
  )
  grid <- matrix(NA_integer_, dims[1L], dims[2L])
  coords <- t(t(coords) + c(1L, 1L))
  grid[coords] <- 1:nrow(coords)
  grid
}

fill_positions <- function(coords = puzzle_data) {
  grid <- embed_positions(coords)
  coords <- t(t(coords) + c(1L, 1L))
  all_pos <- cbind(c(row(grid)), c(col(grid)))
  dis <- abs(outer(all_pos[, 1L], coords[, 1L], `-`)) + 
    abs(outer(all_pos[, 2L], coords[, 2L], `-`))
  closest <- apply(dis, 1L, function(row) {
    min_idx <- which(row == min(row))
    if (length(min_idx) == 1L) {
      min_idx
    } else {
      NA_integer_
    }
  })
  grid[] <- closest
  grid
}

count_area <- function(coords = puzzle_data) {
  grid <- fill_positions(coords)
  border <- c(
    grid[c(1, nrow(grid)), ],
    grid[, c(1, ncol(grid))]
  ) %>% 
    unique()
  grid <- c(grid)
  dist <- table(grid[!grid %in% border])
  max(dist)
}

count_area(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

We calculate the distance of each coordinate in the matrix and count positions which are
within the distance.

```{r get-solution-2}
mark_positions <- function(coords = puzzle_data, max_distance = 10000L) {
  grid <- embed_positions(coords)
  coords <- t(t(coords) + c(1L, 1L))
  all_pos <- cbind(c(row(grid)), c(col(grid)))
  dis <- abs(outer(all_pos[, 1L], coords[, 1L], `-`)) + 
    abs(outer(all_pos[, 2L], coords[, 2L], `-`)) 
  dis <- rowSums(dis) < max_distance
  grid[] <- dis
  grid
}

count_safe_area <- function(coords = puzzle_input, max_distance = 10000L) {
  grid <- mark_positions(coords, max_distance)
  sum(grid)
}
count_safe_area(puzzle_data, 10000L)
```
