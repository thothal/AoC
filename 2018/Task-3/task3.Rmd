---
params:
   task_nr: 3
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_extract_all("\\d+") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("id", "x", "y", "w", "h")) %>% 
    as_tibble() %>% 
    mutate(across(everything(), as.integer))
  
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
example_data <- parse_puzzle_data()
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We go for a brute force algorithm. We create a matrix large enough to cover all fabric
coordinates, then loop through all areas and increase an overlap counter for each 
position. Eventually, we coutn how often the overlap counter was larger than one.


```{r get-solution-1}
create_overlaps <- function(x = puzzle_data) {
  coords <- x %>% 
    mutate(
      id = id,
      x1 = x + 1L,
      y1 = y + 1L,
      x2 = x + w,
      y2 = y + h,
      .keep = "none")
  max_x <- max(coords$x2)
  max_y <- max(coords$y2)
  grid <- matrix(0L, max_x, max_y)
  for (i in 1:nrow(coords)) {
    xs <- coords$x1[i]:coords$x2[i]
    ys <- coords$y1[i]:coords$y2[i]
    grid[xs, ys] <- grid[xs, ys] + 1L
  }
  attr(grid, "coords") <- coords
  grid
}
overlap_grid <- create_overlaps(puzzle_data)
sum(overlap_grid > 1L)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we follow the same idea, and iterate through all coordinates again
and check whether all coordinates covered by the fabric are covered only once. If this is
the case we found the right fabric.

```{r get-solution-2}
find_single_match <- function(grid) {
 coords <- attr(grid, "coords")
  for (i in 1:nrow(coords)) {
    xs <- coords$x1[i]:coords$x2[i]
    ys <- coords$y1[i]:coords$y2[i]
    if (all(grid[xs, ys] == 1L)) {
      return(coords$id[i])
    }
  }
  NA_integer_  
}
find_single_match(overlap_grid)
```
