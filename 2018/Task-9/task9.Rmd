---
params:
   task_nr: 9
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(bit64)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
   str_extract_all("\\d+") %>% 
    extract2(1L) %>% 
    as.integer() %>% 
    as.list() %>% 
    set_names("nr_players", "nr_marbles")
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
example_data <-list(nr_players = 30L, nr_marbles = 5807L)
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

As copying vectors is expensive in `R` we store for each marble index the marble index
of its left and right neighbor. Then for any insert or remove, we just need to update
these indices which can be done in `O(1)`.

```{r get-solution-1}
play_marbles <- function(nm = puzzle_data$nr_marbles, np = puzzle_data$nr_players) {
  scores <- integer64(np)
  
  ## we have nm marbles + 1L (for zero)
  size <- nm + 1L
  ## for each marble we store left and right neighbor
  left <- integer(size)
  right <- integer(size)

  ## marble 0 has index 1 and its right/left neighbor is marble with index 1
  left[1L] <- 1L
  right[1L] <- 1L

  current_idx <- 1L 
  cur_player <- 1L

  for (m in seq_len(nm)) {
    marble_idx <- m + 1L ## index for marble m
    if (m %% 23L != 0L) {
      ## need to fit it between right neighbor (one) and 
      ## right neighbor of right neighbor (two)
      one <- right[current_idx]
      two <- right[one]
      right[one] <- marble_idx
      left[marble_idx] <- one
      right[marble_idx] <- two
      left[two] <- marble_idx
      current_idx <- marble_idx
    } else {
      to_remove <- current_idx
      for (i in seq_len(7L)) {
        ## move seven fields to the left
        to_remove <- left[to_remove]
      }
      ## marble value: marble_idx - 1L
      removed_marble <- to_remove - 1L  
      scores[cur_player] <- scores[cur_player] + m + removed_marble

      prev <- left[to_remove]
      nxt <- right[to_remove]
      right[prev] <- nxt
      left[nxt] <- prev
      current_idx <- nxt
    }
    cur_player <- (cur_player %% np) + 1L
  }
  max(scores)
}
play_marbles(puzzle_data$nr_marbles, puzzle_data$nr_players)

```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

We multiply the number of marbles by 100 and re-run the algorithm.

```{r get-solution-2, cache = TRUE}
play_marbles(puzzle_data$nr_marbles * 100L, puzzle_data$nr_players)
```
