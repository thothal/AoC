---
params:
   task_nr: 4
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(lubridate)
library(tidyr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  lines <- vector("list", length(text_block))
  shift <- str_detect(text_block, fixed("shift"))
  lines[shift] <- str_extract_all(
    text_block[shift], 
    "1518-\\d{2}-\\d{2} \\d{2}:\\d{2}|\\d+"
  )
  lines[!shift] <- str_extract_all(
    text_block[!shift],
    "1518-\\d{2}-\\d{2} \\d{2}:\\d{2}|wakes up|falls asleep"
  )
  text_block <- lines %>% 
    do.call(rbind, .) %>% 
    cbind(NA_character_) %>% 
    set_colnames(c("timestamp", "guard_id", "action")) %>% 
    as_tibble() %>% 
    mutate(orig_nr = 1:n(), .before = 1L) %>% 
    mutate(action = if_else(orig_nr %in% which(shift), action, guard_id),
           guard_id = if_else(orig_nr %in% which(shift), guard_id, NA_character_),
           guard_id = as.integer(guard_id),
           timestamp = ymd_hm(timestamp))
  text_block
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

To solve this puzzle we have to bring the notes first into a proper schedule. This is done
by sorting by the timestamps and then, by block of related events calculate the sleeping
time for each guard. The candidate is the guard with the longets sleeping time. For 
finding the bets time, we generate all timestamps between the sleeping intervals, extract
the minute and get the distribution and tkae the minute where the guard was sleeping most 
often.

```{r get-solution-1}
fill_schedule <- function(notes = puzzle_data) {
  notes %>% 
    arrange(timestamp) %>% 
    fill(guard_id) %>% 
    mutate(block = cumsum(is.na(action)),
           .after = orig_nr) %>% 
    mutate(start = if_else(is.na(action) & hour(timestamp) >= 12L, 
                                ceiling_date(timestamp, "hour"), 
                                timestamp),
           .after = timestamp) %>% 
    mutate(end = lead(start) - minutes(1L),
           end = if_else(is.na(end), update(first(start), hour = 00, minute = 59), end),
           .by = block,
           .after = start) %>% 
    mutate(sleeping = if_else(action == "falls asleep", as.integer((end - start) / 60), 
                              NA_integer_))
}

find_guard <- function(schedule) {
  schedule %>% summarize(sleeping = sum(sleeping, na.rm = TRUE), .by = guard_id) %>%
    arrange(desc(sleeping)) %>% 
    slice(1L) %>% 
    pull(guard_id)
}

find_best_time <- function(schedule, guard) {
  schedule %>% 
    filter(guard_id == guard, action == "falls asleep") %>% 
    rowwise() %>% 
    mutate(time_seq = list(seq(from = start, to = end, by = "1 min"))) %>% 
    unnest(c(time_seq)) %>% 
    mutate(minute = minute(time_seq)) %>% 
    count(minute) %>% 
    arrange(desc(n)) %>% 
    slice(1L) %>% 
    pull(minute)
}

solve_strategy_1 <- function(notes = puzzle_data) {
  schedule <- fill_schedule(notes)
  guard <- find_guard(schedule)
  guard * find_best_time(schedule, guard)
}

solve_strategy_1(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For teh second part, we generate the sleeping distribution per minute for all the guards
and find for each guard the minute where the respective guard was asleep most often.
Then we get the single minute over all guards which had the highest count.

```{r get-solution-2}
find_best_minute <- function(schedule) {
  schedule %>% 
    filter(action == "falls asleep") %>% 
    rowwise() %>% 
    mutate(time_seq = list(seq(from = start, to = end, by = "1 min"))) %>% 
    unnest(c(time_seq)) %>% 
    mutate(minute = minute(time_seq)) %>% 
    count(guard_id, minute) %>% 
    arrange(desc(n)) %>% 
    slice(1L)
}

solve_strategy_2 <- function(notes = puzzle_data) {
  schedule <- fill_schedule(notes)
  find_best_minute(schedule) %>% 
    select(guard_id, minute) %>% 
    unlist() %>% 
    prod()
}

solve_strategy_2(puzzle_data)
```
