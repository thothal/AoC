---
params:
   task_nr: 7
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(igraph)
library(gtools)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_extract_all("(?<=[Ss]tep ).") %>% 
    do.call(rbind, .) %>% 
    set_colnames(c("from", "to")) %>% 
    as_tibble()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We construct a graph and then walk the graph according to the rules.

```{r get-solution-1}
create_instruction_graph <- function(instructions = puzzle_data) {
  G <- graph_from_data_frame(instructions)
  roots <- V(G)[which(degree(G, mode = "in") == 0L)]$name
  G <- G + vertex("start")
  new_edges <- c(rbind("start", roots))
  G <- add_edges(G, new_edges)
  graph_attr(G, "layout") <- layout_as_tree(G)
  G
}

follow_instructions <- function(instructions = puzzle_data) {
  G <- create_instruction_graph(instructions)
  root <- which(degree(G, mode = "in") == 0L)
  path <- character(0L)
  kids <- neighbors(G, root, "out")$name %>% 
    sort()
  while (length(kids) > 0L) {
    next_node <- kids[1L]
    path <- c(path, next_node)
    next_kids <- neighbors(G, next_node, "out")$name %>% 
      keep(~ all(neighbors(G, .x, "in")$name %in% path))
    kids <- c(tail(kids, -1L), next_kids) %>% 
      sort()
  }
  paste(path, collapse = "")
}
follow_instructions(puzzle_data)

```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For this part, we create a list of workers, which store the piece they are currently
assembling and the time they still need. Then, we iterate through the time, setting the
time jumps to the minimum time any worker still needs (nothing of interest happens in
between). Once a worker is done, we check whether the construction of the piece unlock a 
new piece. If this is the case, we add it to the list of pieces available for assembly.

To check whether a new piece can be added to the assembly list we use the graph 
constructed before. A new piece can be added, whenever all of its parents are already 
assembled.

Whenever a worker is idle we assign a new piece from the list of pieces ready for 
assembly. We add the time jumps and eventually return it.

```{r get-solution-2}
get_min_time <- function(instructions = puzzle_data, nr_workers = 5L) {
  G <- create_instruction_graph(instructions)
  V(G)$time <- vapply(V(G), function(v) utf8ToInt(V(G)[v]$name)[[1L]] - 4L, integer(1L))
  V(G)["start"]$time <- NA_integer_
  ## what is worker i working on and how long does it take
  workers <- rep(list(list(remaining = 0L, piece = NA_character_)),
                 nr_workers)

  done <- rep(FALSE, vcount(G)) %>% 
    set_names(V(G)$name)
  done["start"] <- TRUE
  time <- 0L
  time_shift <- 1L
  parents <- adjacent_vertices(G, V(G), "in")
  parents$start <- NULL
  cand <- neighbors(G, "start")$name
  while (!all(done)) {
    for (wid in seq_along(workers)) {
      ## worker have worked another sec on this pirce
      workers[[wid]]$remaining <- max(workers[[wid]]$remaining - time_shift, 0L)
      if (workers[[wid]]$remaining == 0L) {
        piece <- workers[[wid]]$piece
        if (!is.na(piece)) {
          done[piece] <- TRUE
          kids <- neighbors(G, piece)$name
          kids <- keep(kids, ~ all(parents[[.x]]$name %in% names(which(done)))) 
          cand <- c(cand, kids)
          workers[[wid]]$piece <- NA_character_
        }
      }
    }
    time_min <- Inf
    for (wid in seq_along(workers)) {
      if (length(cand) > 0L) {
        piece <- workers[[wid]]$piece
        if (is.na(piece)) {
          ## worker wid is idle
          new_piece <- head(cand, 1L)
          cand <- tail(cand, -1L)
          workers[[wid]]$remaining <- V(G)[new_piece]$time
          workers[[wid]]$piece <- new_piece
        }
      }
      time_min <- min(time_min, 
                      if_else(workers[[wid]]$remaining == 0L, Inf, 
                              workers[[wid]]$remaining))
    }
    time <- time + time_shift
    time_shift <- time_min
  }
  time - 1L
}
get_min_time(puzzle_data, 5L)
```
