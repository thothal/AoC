---
params:
   task_nr: 13
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_split("") %>% 
    do.call(rbind, .)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
example_data <- parse_puzzle_data()
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
puzzle[[1]] <- str_replace(puzzle[[1]], "<code>\\\\</code>", "<code>\\\\\\\\</code>")
cat(puzzle[[1]])
```

### Solution

For the first part, we keep a matrix of the position of the carts together with
their current orientation. Each tick they move by one field, where we check the 
condition, if it is an intersection we turn the cart and if it is another cart we report
a collision. To mimick the order of movement, we sort the cart matrix by row and column.

In a first attempt we used vectorization for the movements, but then we missed 
collisions of passing cars. Hence, we decided to go for moving one cart at a time.

We use an environment to pass the cart positions and the map to the `move_cart` function
to avoid copying large matrices over and over again.


```{r get-solution-1}
move_cart <- function(track, start_from = 1L) {
  dirs <- c("^" = 1L, ">" = 2L, "v" = 3L, "<" = 4L)
  offset <- rbind(
    "^" = c(-1L, 0L),
    ">" = c(0L, 1L),
    "v" = c(1L, 0L),
    "<" = c(0L, -1L)
  )
  crash <- FALSE
  for (cart_idx in seq(start_from, nrow(track$carts))) {
    ## unfortunately we need to cycle cart by cart to detect collisions
    ## if we do it vectorized we may overlook swap collisions
    if (track$carts[cart_idx, "crashed"] == 1L) {
      next
    }
    track$carts[cart_idx, 1:2] <- track$carts[cart_idx, 1:2] + 
      offset[track$carts[cart_idx, "dir"], ]
    crashed <- duplicated(track$carts[track$carts[, "crashed"] != 1L, 1:2])
    if (any(crashed)) {
      crash <- TRUE
      crashed_cart <- cart_idx
      track$carts[duplicated(track$carts[, 1:2]) |
                    duplicated(track$carts[, 1:2], fromLast = TRUE), 
                  "crashed"] <- 1L
      attr(crash, "crashed_cart") <- crashed_cart
      return(crash)
    }
    new_pos <- track$map[track$carts[cart_idx, 1:2, drop = FALSE]]
    can_turn <- new_pos == "+"
    must_turn <- new_pos %in% c("\\", "/")
    if (must_turn) {
      track$carts[cart_idx, "dir"] <- (
        track$carts[cart_idx, "dir"] +
          case_when(
            new_pos == "/" & track$carts[cart_idx, "dir"] %in% c(1L, 3L) ~ 1L,
            new_pos == "/" & track$carts[cart_idx, "dir"] %in% c(2L, 4L) ~ -1L,
            new_pos == "\\" & track$carts[cart_idx, "dir"] %in% c(2L, 4L) ~ 1L,
            new_pos == "\\" & track$carts[cart_idx, "dir"] %in% c(1L, 3L) ~ -1L
          ) - 1L) %% 4L + 1L
    }
    if (can_turn) {
      track$carts[cart_idx, "dir"] <- (
        track$carts[cart_idx, "dir"] +
          case_when(
            track$carts[cart_idx, "turn_idx"] %% 3L == 0L ~ -1L,
            track$carts[cart_idx, "turn_idx"] %% 3L == 1L ~ 0L,
            track$carts[cart_idx, "turn_idx"] %% 3L == 2L ~ 1L
          ) - 1L) %% 4L + 1L
      track$carts[cart_idx, "turn_idx"] <- track$carts[cart_idx, "turn_idx"] + 1L
    }
  }
  track$carts <- track$carts[order(track$carts[, 2], 
                                          track$carts[, 1]), , drop = FALSE]
  attr(crash, "crashed_cart") <- NULL
  crash
}

setup_track <- function(orig_map) {
  carts <- which(orig_map == ">" |
                   orig_map == "v" |
                   orig_map == "<"|
                   orig_map == "^", arr.ind = TRUE)
  ## remove cart from map
  map <- orig_map
  map[carts] <- if_else(map[carts] %in% c("<", ">"), "-", "|")
  dirs <- c("^" = 1L, ">" = 2L, "v" = 3L, "<" = 4L)
  carts <- cbind(carts, turn_idx = 0L, dir = dirs[orig_map[carts]], crashed = 0L)
  carts <- carts[order(carts[, 2], carts[, 1]), , drop = FALSE]
  rownames(carts) <- LETTERS[seq_len(nrow(carts))]
  track <- new.env()
  track$carts <- carts
  track$map <- map
  track
}

get_first_crash <- function(orig_map = puzzle_data) {
  track <- setup_track(orig_map)
  crash <- FALSE
  tick <- 0L
  while (!crash) {
    crash <- move_cart(track, 1L)
    tick <- tick + 1L 
  }
  crash_idx <- which(track$carts[, "crashed"] == 1L)[[1L]]
  paste(track$carts[crash_idx, 2:1] - 1L, collapse = ",")
}

get_first_crash(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

We reuse the `move_cart` function from part 1. We just have to resume the moving right
after the crashed cart and keep count of the surviving carts. In the end we have to
check whether the crash ahppened before the last cart could move. If so, let the last cart
move once more.

```{r get-solution-2}
get_surving_cart <- function(orig_map = puzzle_data) {
  track <- setup_track(orig_map)
  nr_carts <- nrow(track$carts)
  tick <- 0L
  first_cart <- 1L
  while (nr_carts > 1L) {
    crash <- move_cart(track, first_cart)
    if (crash) {
      crashed_cart <- attr(crash, "crashed_cart")
      first_cart <- crashed_cart
      nr_carts <- nr_carts - 2L
    } else {
      first_cart <- 1L
    }
    tick <- tick + 1L
  }
  surv_idx <- which(track$carts[, "crashed"] == 0L)
  if (surv_idx > attr(crash, "crashed_cart")) {
    move_cart(track, surv_idx)
  }
  paste(track$carts[surv_idx, 2:1] - 1L, collapse = ",")
}
get_surving_cart(puzzle_data)
```
