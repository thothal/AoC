---
params:
   task_nr: 17
   year: 2018
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(tidyr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  x <- str_extract(text_block, "x=\\d+(..\\d+)?") %>% 
    str_extract_all("\\d+") %>% 
    map(~ rep(as.integer(.x), 2L)[1:2] %>% 
          set_names(c("x0", "x1"))) %>% 
    do.call(rbind, .)
  y <- str_extract(text_block, "y=\\d+(..\\d+)?") %>% 
    str_extract_all("\\d+")%>% 
    map(~ rep(as.integer(.x), 2L)[1:2] %>% 
          set_names(c("y0", "y1")))%>% 
    do.call(rbind, .)
 cbind(x, y) %>% 
   as_tibble()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
example_data <- parse_puzzle_data()
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

After many tries to implement a recursive solution, we eventually decided to go for an 
iterative version. We add an element to the queue, whenever we move down. If we observe
an overflow, we add the first element protruding over the obstacle to the queue as well.
Whenever we flood to either side, we keep track, if a new piece was wetted. If so, we 
reattach the current position to the queue, because there may be a situation where we 
first flood to the left (right), overflow, fill up the lower basin and then we can 
further flood to the left (right). Finally, whenever we left and right end of a flooded 
area are limited by `#`, we replace flowing water (`|`) by resting water (`~`).

Eventually, we just have to count wet fields, taking into account that the first rows 
above the first clay basin should not be counted.

```{r get-solution-1}
print.ground <- function(x, ...) {
  rows <- apply(x, 1, paste, collapse = "")
  max_width <- max(nchar(names(rows)))
  rows <- imap_chr(rows, ~ paste0(str_pad(.y, max_width, "right"), ": ", .x))
  paste(rows, collapse = "\n") %>% 
    cat("\n")
  invisible(x)
}

create_ground <- function(clay_coords = puzzle_data) {
  ## +3 to create two columns to the left and the right
  ground <- clay_coords %>% 
    summarize(data = ".", ncol = max(x1) - min(x0) + 3L, nrow = max(y1)) %>% 
    do.call(matrix, .)
  spring <- bottom <- rep(".", ncol(ground))
  spring_pos <- clay_coords %>% 
    summarize(spring_pos = 500L - min(x0) + 2L) %>% 
    pull(spring_pos)
  spring[spring_pos] <- "x"
  ground <- rbind(spring, ground, bottom)
  rownames(ground) <- 0:(nrow(ground) - 1L)
  class(ground) <- "ground"
  min_col <- clay_coords %>% 
    summarize(min_col = min(x0)) %>% 
    pull(min_col)
  min_row <- clay_coords %>% 
    summarize(min_row = min(min(y0), min(y1))) %>% 
    pull(min_row)
  idx <- apply(clay_coords, 1, function(r) {
    expand.grid(row = r["y0"]:r["y1"] + 1L,
                col = r["x0"]:r["x1"] - min_col + 2L)
  }) %>% 
    do.call(rbind, .) %>% 
    as.matrix()
  ground[idx] <- "#"
  attr(ground, "spring_pos") <- spring_pos
  attr(ground, "count_start") <- min_row
  ground
}

count_wet_tiles <- function(clay_coords = puzzle_data) {
  ground <- create_ground(clay_coords)
  pos <- cbind(2L, attr(ground, "spring_pos"))
  dirs <- rbind(
    "v" = c(1L, 0L),
    "<" = c(0L, -1L),
    ">" = c(0L, 1L),
    "^" = c(-1L, 0L)
  )
  move <- function(pos, dir) {
    for (d in dir) {
      pos <-t(t(pos) + dirs[dir, ])
    }
    pos
  }
  flood <- function(pos, dir) {
    did_flow <- FALSE
    overflow <- FALSE
    nb <- move(pos, dir)
    while (ground[nb] %in% c(".", "|") && 
           ground[move(nb, "v")] %in% c("#", "~") &&
           ground[move(pos, "v")] %in% c("#", "~") && 
           between(pos[2L], 1L, ncol(ground))) {
      if (ground[nb] == ".") {
        did_flow <- TRUE
      }
      ground[nb] <<- "|"
      nb <- move(nb, dir)
    }
    if (ground[nb] == "." && ground[move(pos, "v")] %in% c("#", "~")) {
      ## overflow if we hit a ~ or # and it is free (.)
      if (ground[nb] == ".") {
        did_flow <- TRUE
      }
      ground[nb] <<- "|"
      overflow <- TRUE
    }
    if (!between(nb[2L], 1L, ncol(ground))) {
      nb <- pos
    }
    attr(nb, "overflow") <- overflow
    attr(nb, "did_flow") <- did_flow
    nb
  }
  drop <- function(pos) {

    queue <- pos
    
    push <- function(pos, at_end = TRUE) {
      if (!anyDuplicated(rbind(pos, queue))) {
        if (at_end) {
          queue <<- rbind(queue, pos)
        } else {
          queue <<- rbind(pos, queue)
        }
      }
    }
    while (nrow(queue) > 0) {
      pos <- head(queue, 1L)
      queue <- tail(queue, -1L)
      if (pos[1L] >= nrow(ground)) {
        ## we hit the bottom
        next
      }
      ground[pos] <<- if_else(ground[pos] == ".", "|", ground[pos])
      if (ground[move(pos, "v")] == ".") {
        ## move down if free
        push(move(pos, "v"), FALSE)
      }
      ## flood to the left
      left <- flood(pos, "<")
      if (attr(left, "overflow")) {
        push(left)
      }
      if (attr(left, "did_flow")) {
        push(pos)
      }
      ## flood to the right
      right <- flood(pos, ">")
      if (attr(right, "overflow")) {
        push(right)
      }
      if (attr(right, "did_flow")) {
        push(pos)
      }
      if (ground[left] == "#" && ground[right] == "#") {
        ground[pos[1L], (left[2L] + 1L):(right[2L] - 1L)] <<- "~"
        push(move(pos, "^"), FALSE)
      }
    }
  }
  drop(pos)
  count_start <- attr(ground, "count_start")
  list(wet = sum(ground[-c(nrow(ground), 1:count_start), ] %in% c("|", "~")),
       at_rest =  sum(ground[-c(nrow(ground), 1:count_start), ] == "~"))
}
res <- count_wet_tiles(puzzle_data)
res$wet
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we simply have to count only fields with water at rest (`~`).

```{r get-solution-2}
res$at_rest
```
