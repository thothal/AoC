---
params:
   task_nr: 7
   year: 2019
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(gtools)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_split(",") %>% 
    do.call(c, .) %>% 
    as.integer()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We reuse our parser from [Day 5 @ 2019](2019_task5.html) and adapt it to read the input
from  a stack. We also let the ops return `TRUE` or `FALSE` to indicate whether they
successfully finished. This is important to signal that we are waiting for an input, which
is not yet here. In this case, the op return `FALSE` and the main loop returns early (and
stores the current state, that is the op codes and the instruction pointer).

With this information we can resume the program as soon as new input arrives. This is
mainly needed for the second part of the puzzle. For the first part though, we simply
pass the 2 required inputs to the amplifier programs and cycle through all different phase
settings to find the maximum output.

```{r get-solution-1}
split_digits <- function(n) {
  i <- floor(log10(n)) + 1L
  digits <- integer(i)
  while (n > 0) {
    digits[i] <- n %% 10L
    n <- n %/% 10L
    i <- i - 1L
  }
  digits
}

parse_op_codes <- function(input, op_codes = puzzle_data, ip = 1L, 
                           verbose = FALSE) {
  out_buffer <- integer(0L)
  add <- function(x, y, res, modes) {
    if (modes[1L] == 0L) {
      x <- op_codes[x + 1L]
    }
    if (modes[2L] == 0L) {
      y <- op_codes[y + 1L]
    }
    op_codes[[res + 1L]] <<- x + y
    ip <<- ip + 4L
    TRUE
  }
  mul <- function(x, y, res, modes) {
    if (modes[1L] == 0L) {
      x <- op_codes[x + 1L]
    }
    if (modes[2L] == 0L) {
      y <- op_codes[y + 1L]
    }
    op_codes[[res + 1L]] <<- x * y
    ip <<- ip + 4L
    TRUE
  }
  set <- function(res, ..., modes) {
    if (length(input) == 0L) {
      return (FALSE)
    }
    op_codes[[res + 1L]] <<- head(input, 1L)
    ip <<- ip + 2L
    input <<- tail(input, -1L)
    TRUE
  }
  out <- function(x, ..., modes) {
    if (modes[1L] == 0L) {
      x <- op_codes[x + 1L]
    }
    out_buffer <<- c(out_buffer, x)
    if (verbose) {
      cat(x, "\n")
    }
    ip <<- ip + 2L
    TRUE
  }
  jnz <- function(x, y, ..., modes) {
    if (modes[1L] == 0L) {
      x <- op_codes[x + 1L]
    }
    if (modes[2L] == 0L) {
      y <- op_codes[y + 1L]
    }
    if (x != 0L) {
      ip <<- y + 1L  
    } else {
      ip <<- ip + 3L
    }
    TRUE
  }
  jeqz <- function(x, y, ..., modes) {
    if (modes[1L] == 0L) {
      x <- op_codes[x + 1L]
    }
    if (modes[2L] == 0L) {
      y <- op_codes[y + 1L]
    }
    if (x == 0L) {
      ip <<- y + 1L  
    } else {
      ip <<- ip + 3L
    }
    TRUE
  }
  lt <- function(x, y, res, modes) {
    if (modes[1L] == 0L) {
      x <- op_codes[x + 1L]
    }
    if (modes[2L] == 0L) {
      y <- op_codes[y + 1L]
    }
    op_codes[[res + 1L]] <<- (x < y)
    ip <<- ip + 4L
    TRUE
  }
  eq <- function(x, y, res, modes) {
    if (modes[1L] == 0L) {
      x <- op_codes[x + 1L]
    }
    if (modes[2L] == 0L) {
      y <- op_codes[y + 1L]
    }
    op_codes[[res + 1L]] <<- (x == y)
    ip <<- ip + 4L
    TRUE
  }
  
  ops <- list(add, mul, set, out, jnz, jeqz, lt, eq)
  get_op <- function(op_code) {
    digits <- split_digits(op_code)
    n <- length(digits)
    digits <- c(rep(0L, 5L), digits)[seq(n + 1L, length.out = 5L)]
    list(op = sum(digits[5:4] * 10L ^ (0:1)),
         modes = digits[3:1])
  }
  n <- length(op_codes)
  op <- get_op(op_codes[ip])
  done <- TRUE
  while(ip <= n && op$op %in% c(seq_along(ops), 99L)) {
    args <- as.list(op_codes[seq(ip + 1L, length.out = 3L)])
    cont <- do.call(ops[[op$op]], c(args, modes = list(op$modes)))
    if (!cont) {
      done <- FALSE
      break
    }
    op <- get_op(op_codes[ip])
    if (op$op == 99L) {
      break
    } else if (!op$op %in% seq_along(ops)) {
      cat("Unknown op code", op$op, "\n")
    }
  }
  attr(out_buffer, "status") <- list(ip = ip, op_codes = op_codes, done = done)
  out_buffer
}

find_max_thrust <- function(op_codes = puzzle_data, verbose = FALSE) {
  all_codes <- permutations(5L, 5L, 0:4)
  n <- nrow(all_codes)
  max_out <- -.Machine$integer.max
  for (i in seq_len(n)) {
    code <- all_codes[i, ]
    code <- c(code[1L], 0L, tail(code, -1L))
    for (amp_id in 1:5) {
      input <- head(code, 2L)
      out <- parse_op_codes(input, op_codes) %>% 
        tail(1L)
      if (amp_id != 5) {
        code <- tail(code, -2L)
        code <- c(code[1L], out, tail(code, -1L))
      }
    }
    max_out <- max(max_out, out)
  }
  max_out
}

find_max_thrust(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we create an infinite loop where the output of the previous amplifier
is fed to the next one. Whenever an amplifier produces an output, we fed it to the next, 
while the previous amplifier is in waiting mode to receive its next input. We continue
this infinite loop until all amplifiers signaled their proper termination.

```{r get-solution-2}
find_max_thrust_loop <- function(op_codes = puzzle_data, verbose = FALSE) {
  all_codes <- permutations(5L, 5L, 5:9)
  n <- nrow(all_codes)
  max_out <- -.Machine$integer.max
  for (i in seq_len(n)) {
    code <- all_codes[i, ]
    code <- c(code[1L], 0L, tail(code, -1L))
    amplifiers <- rep(list(list(op_codes = op_codes, ip = 1L, done = FALSE)), 5L)
    while (TRUE) {
      for (amp_id in seq_along(amplifiers)) {
        input <- head(code, min(2L, length(code)))
        amp <- amplifiers[[amp_id]]
        out <- parse_op_codes(input, amp$op_codes, amp$ip)
        amplifiers[[amp_id]] <- attr(out, "status")
        attr(out, "status") <- NULL
        code <- tail(code, -2L)
        if (length(code) == 0L) {
          code <- out
        } else {
          code <- c(code[1L], out, tail(code, -1L))
        }
      }
      if (all(vapply(amplifiers, \(a) a$done, logical(1L)))) {
        break
      }
    }
    max_out <- max(max_out, out)
  }
  max_out
}

find_max_thrust_loop(puzzle_data)
```
