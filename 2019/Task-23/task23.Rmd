---
params:
   task_nr: 23
   year: 2019
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
 text_block %>% 
    str_split(",") %>% 
    do.call(c, .) %>% 
    as.numeric()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We build upon the code from [Day 21 @ 2019](2019_task21.html). We loop through all nodes
and run the intcodes. If a node is expecting some input and its queue is empty, we
return the control to the next node. We need to return the complete state (i.e. relative
base instruction pointer and intcodes), to be able to resume execution from the last 
break point.

*N.B.* We included some code needed only for part 2 of the puzzle.

```{r get-solution-1}
parse_op_codes_fast <- function(op_codes = as.numeric(puzzle_data), input = numeric(), 
                                ip = 1L, rel_base = 0L, has_booted = FALSE, 
                                verbose = FALSE) {
  out_buffer <- numeric(0L)
  out_len <- 0L
  out_block <- 300L
  block_size <- 1024L
  
  grow_memory <- function(idx) {
    if (idx > length(op_codes)) {
      new_size <- ceiling(idx / block_size) * block_size
      op_codes <<- c(op_codes, rep(0L, new_size - length(op_codes)))
    }
  }
  
  append_out <- function(val) {
    if (out_len + 1L > length(out_buffer)) {
      new_size <- length(out_buffer) + out_block
      out_buffer <<- c(out_buffer, rep(0L, new_size - length(out_buffer)))
    }
    out_len <<- out_len + 1L
    out_buffer[out_len] <<- val
  }
  
  get_val <- function(param, mode) {
    if (mode == 0L) {
      grow_memory(param + 1L)
      return(op_codes[param + 1L])
    } else if (mode == 1L) {
      return(param)
    } else if (mode == 2L) {
      idx <- rel_base + param + 1L
      grow_memory(idx)
      return(op_codes[idx])
    } else {
      stop("unknown mode")
    }
  }
  
  get_addr <- function(param, mode) {
    if (mode == 0L) {
      return(param + 1L)
    } else if (mode == 2L) {
      return(rel_base + param + 1L)
    } else {
      stop("invalid write mode")
    }
  }
  
  halt <- FALSE
  while (!halt) {
    instr <- op_codes[ip]
    op <- instr %% 100L
    modes <- c(
      (instr %/% 100L) %% 10L, 
      (instr %/% 1000L) %% 10L, 
      (instr %/% 10000L) %% 10L
    )
    
    if (op == 1L) { # add
      a <- get_val(op_codes[ip + 1L], modes[1L])
      b <- get_val(op_codes[ip + 2L], modes[2L])
      addr <- get_addr(op_codes[ip + 3L], modes[3L])
      grow_memory(addr)
      op_codes[addr] <- a + b
      ip <- ip + 4L
    } else if (op == 2L) { # mul
      a <- get_val(op_codes[ip + 1L], modes[1L])
      b <- get_val(op_codes[ip + 2L], modes[2L])
      addr <- get_addr(op_codes[ip + 3L], modes[3L])
      grow_memory(addr)
      op_codes[addr] <- a * b
      ip <- ip + 4L
    } else if (op == 3L) { # input
      if (length(input) == 0L) {
        ## no input yet
        halt <- TRUE
      } else {
        addr <- get_addr(op_codes[ip + 1L], modes[1])
        grow_memory(addr)
        op_codes[addr] <- input[1L]
        input <- input[-1L]
        if (!has_booted) {
          if (verbose) {
            cat("node", op_codes[addr], "booted...\n")
          }
          has_booted <- TRUE
        } 
        ip <- ip + 2L
      }
    } else if (op == 4L) { # output
      val <- get_val(op_codes[ip + 1L], modes[1])
      append_out(val)
      if (verbose) cat(val, "\n")
      ip <- ip + 2L
    } else if (op == 5L) { # jump-if-true
      a <- get_val(op_codes[ip + 1L], modes[1L])
      b <- get_val(op_codes[ip + 2L], modes[2L])
      if (a != 0L) {
        ip <- b + 1L
      } else {
        ip <- ip + 3L
      }
    } else if (op == 6L) { # jump-if-false
      a <- get_val(op_codes[ip + 1L], modes[1L])
      b <- get_val(op_codes[ip + 2L], modes[2L])
      if (a == 0L) {
        ip <- b + 1L
      } else {
        ip <- ip + 3L
      }
    } else if (op == 7L) { # less than
      a <- get_val(op_codes[ip + 1L], modes[1L])
      b <- get_val(op_codes[ip + 2L], modes[2L])
      addr <- get_addr(op_codes[ip + 3L], modes[3L])
      grow_memory(addr)
      op_codes[addr] <- as.numeric(a < b)
      ip <- ip + 4L
    } else if (op == 8L) { # equals
      a <- get_val(op_codes[ip + 1L], modes[1L])
      b <- get_val(op_codes[ip + 2L], modes[2L])
      addr <- get_addr(op_codes[ip + 3L], modes[3L])
      grow_memory(addr)
      op_codes[addr] <- as.numeric(a == b)
      ip <- ip + 4L
    } else if (op == 9L) { # adjust relative base
      a <- get_val(op_codes[ip + 1L], modes[1L])
      rel_base <- rel_base + a
      ip <- ip + 2L
    } else if (op == 99L) { # halt
      halt <- TRUE
    } else {
      stop("Unknown opcode ", op)
    }
  }
  res <- out_buffer[1:out_len]
  attr(res, "status") <- list(op_codes = op_codes, ip = ip, rel_base = rel_base,
                                     has_booted = has_booted)
  res
}

start_network <- function(nic, use_nat = FALSE) {
  nodes <- vector("list", 50)
  queues <- vector("list", 50)
  for(i in 0:49) {
    res <- parse_op_codes_fast(nic, i)
    nodes[[i + 1]] <- list(nic = attr(res, "status"), packet_part = 0L)
    queues[[i + 1]] <- list() 
  }
  nat_packet <- NULL
  nat_sent_history <- numeric(0L)
  while(TRUE) {
    for (i in 1:50) {
      node <- nodes[[i]]
      if (length(queues[[i]]) > 0L) {
        node$nic$input <- queues[[i]][[1L]][[node$packet_part + 1L]]
        if (node$packet_part == 1L) {
          queues[[i]] <- queues[[i]][-1L]
        }
        node$packet_part <- (node$packet_part + 1L) %% 2L
      } else {
        node$nic$input <- -1L
      }
      
      res <- do.call(parse_op_codes_fast, node$nic)
      node$nic <- attr(res, "status")
      
      while (length(res) >= 3L) {
        dest <- res[1L]
        packet <- list(X = res[2L], Y = res[3L])
        if (dest == 255L) {
          if (!use_nat) {
            cat("\n")
            return (packet$Y)
          } else {
            nat_packet <- packet
          }
        } else {
          queues[[dest + 1L]] <- c(queues[[dest + 1L]], list(packet))
        }
        res <- res[-(1:3)]
      }
      nodes[[i]] <- node
    }
    if (use_nat) {
      all_empty <- all(lengths(queues) == 0L)
      if (all_empty && !is.null(nat_packet)) {
        queues[[1L]] <- c(queues[[1L]], list(nat_packet))
        nat_sent_history <- c(nat_sent_history, nat_packet$Y)
        n <- length(nat_sent_history)
        if (n >= 2L && nat_sent_history[n] == nat_sent_history[n - 1L]) {
        return(nat_packet$Y)
        }
      }
    }
  }
}
start_network(as.numeric(puzzle_data))
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

We switch on the NAT logic, where packets sent to address 255 are handled separately.

```{r get-solution-2}
start_network(as.numeric(puzzle_data), TRUE)
```

