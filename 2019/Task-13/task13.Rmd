---
params:
   task_nr: 13
   year: 2019
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(bit64)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
 text_block %>% 
    str_split(",") %>% 
    do.call(c, .) %>% 
    as.integer64()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We use the code from [Day 11 @ 2019](2019_task11.html) as basis and store the tiles 
coordinates and their type. Then, we just have to count the blocks.

*N.B.* The code also includes input logic, which we only need for part 2.

```{r get-solution-1}
parse_op_codes_fast <- function(op_codes = as.numeric(puzzle_data), input = numeric(), 
                                verbose = FALSE) {
  ip <- 1L
  rel_base <- 0L
  out_buffer <- numeric(0)
  out_len <- 0L
  out_block <- 3L
  block_size <- 3L  # size of memory
  tiles <- matrix(NA_integer_, 0L, 3L, dimnames = list(NULL, c("x", "y", "bt")))
  grow_memory <- function(idx) {
    if (idx > length(op_codes)) {
      new_size <- ceiling(idx / block_size) * block_size
      op_codes <<- c(op_codes, rep(0, new_size - length(op_codes)))
    }
  }
  
  append_out <- function(val) {
    if (out_len + 1L > length(out_buffer)) {
      new_size <- length(out_buffer) + out_block
      out_buffer <<- c(out_buffer, rep(0, new_size - length(out_buffer)))
    }
    out_len <<- out_len + 1L
    out_buffer[out_len] <<- val
  }
  
  get_val <- function(param, mode) {
    if (mode == 0L) {
      grow_memory(param + 1L)
      return(op_codes[param + 1L])
    } else if (mode == 1L) {
      return(param)
    } else if (mode == 2L) {
      idx <- rel_base + param + 1L
      grow_memory(idx)
      return(op_codes[idx])
    } else {
      stop("unknown mode")
    }
  }
  
  get_addr <- function(param, mode) {
    if (mode == 0L) {
      return(param + 1L)
    } else if (mode == 2L) {
      return(rel_base + param + 1L)
    } else {
      stop("invalid write mode")
    }
  }
  
  halt <- FALSE
  ball_pos <- paddle_pos <- NULL
  while (!halt) {
    instr <- op_codes[ip]
    op <- instr %% 100L
    modes <- c(
      (instr %/% 100L) %% 10L, 
      (instr %/% 1000L) %% 10L, 
      (instr %/% 10000L) %% 10L
    )
    
    if (op == 1L) { # add
      a <- get_val(op_codes[ip + 1L], modes[1])
      b <- get_val(op_codes[ip + 2L], modes[2])
      addr <- get_addr(op_codes[ip + 3L], modes[3])
      grow_memory(addr)
      op_codes[addr] <- a + b
      ip <- ip + 4L
    } else if (op == 2L) { # mul
      a <- get_val(op_codes[ip + 1L], modes[1])
      b <- get_val(op_codes[ip + 2L], modes[2])
      addr <- get_addr(op_codes[ip + 3L], modes[3])
      grow_memory(addr)
      op_codes[addr] <- a * b
      ip <- ip + 4L
    } else if (op == 3L) { # input
      ## move into the direction of the ball
      input <- sign(ball_pos[1L] - paddle_pos[1L])
      addr <- get_addr(op_codes[ip + 1L], modes[1])
      grow_memory(addr)
      op_codes[addr] <- input[1L]
      input <- input[-1]
      ip <- ip + 2L
    } else if (op == 4L) { # output
      val <- get_val(op_codes[ip + 1L], modes[1])
      append_out(val)
      if (out_len %% 3L == 0L) {
        ## we got a full triple
        new_line <- as.integer(out_buffer[1:3])
        out_len <- 0L
        idx <- which(tiles[, 1L] == new_line[1L] & tiles[, 2L] == new_line[2L])
        if (length(idx) == 1L) {
          tiles[idx, 3L] <- new_line[3L]
        } else {
          stopifnot(length(idx) == 0L)
          tiles <- rbind(tiles, new_line)
        }
        class(tiles) <- "tiles"
        if (!identical(new_line[1:2], c(-1L, 0L))) {
          if (new_line[3L] == 3L) {
            paddle_pos <- new_line[1:2]
          } else if (new_line[3L] == 4L) { # ball
            if (is.null(ball_pos)) {
              # erster Ballframe
              prev_ball_pos <- new_line[1:2]
              ball_pos <- new_line[1:2]
            } else {
              prev_ball_pos <- ball_pos
              ball_pos <- new_line[1:2]
              ball_dir <- ball_pos - prev_ball_pos
            }
          }
        }
      }
      if (verbose) cat(val, "\n")
      ip <- ip + 2L
    } else if (op == 5L) { # jump-if-true
      a <- get_val(op_codes[ip + 1L], modes[1])
      b <- get_val(op_codes[ip + 2L], modes[2])
      if (a != 0L) {
        ip <- b + 1L
      } else {
        ip <- ip + 3L
      }
    } else if (op == 6L) { # jump-if-false
      a <- get_val(op_codes[ip + 1L], modes[1])
      b <- get_val(op_codes[ip + 2L], modes[2])
      if (a == 0L) {
        ip <- b + 1L
      } else {
        ip <- ip + 3L
      }
    } else if (op == 7L) { # less than
      a <- get_val(op_codes[ip + 1L], modes[1])
      b <- get_val(op_codes[ip + 2L], modes[2])
      addr <- get_addr(op_codes[ip + 3L], modes[3])
      grow_memory(addr)
      op_codes[addr] <- as.numeric(a < b)
      ip <- ip + 4L
    } else if (op == 8L) { # equals
      a <- get_val(op_codes[ip + 1L], modes[1])
      b <- get_val(op_codes[ip + 2L], modes[2])
      addr <- get_addr(op_codes[ip + 3L], modes[3])
      grow_memory(addr)
      op_codes[addr] <- as.numeric(a == b)
      ip <- ip + 4L
    } else if (op == 9L) { # adjust relative base
      a <- get_val(op_codes[ip + 1L], modes[1])
      rel_base <- rel_base + a
      ip <- ip + 2L
    } else if (op == 99L) { # halt
      halt <- TRUE
    } else {
      stop("Unknown opcode ", op)
    }
  }
  tiles
}
tiles <- parse_op_codes_fast(as.numeric(puzzle_data))
sum(tiles[, "bt"] == 2L)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we rewrite the input (store a `2` in the first position) and 
determine the perfect joystick movement at each step. We move with the ball, that is, if
the ball is to our right we also move right and if it is to our left we move left.

```{r get-solution-2}
arcade <- as.numeric(puzzle_data)
arcade[1L] <- 2L
arcade_solution <- parse_op_codes_fast(arcade)
arcade_solution[arcade_solution[, 1L] == -1L & arcade_solution[, 2L] == 0L, 3L]
```
