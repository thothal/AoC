---
params:
   task_nr: 16
   year: 2019
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  res <- text_block %>% 
    str_split("") %>% 
    extract2(1L) %>% 
    as.integer()
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

For the first part, we implement the algorithm as is, that is without paying special 
attention to the underlying structure.

```{r get-solution-1}
get_pattern <- function(digit, n) {
  base_pattern <- c(0L, 1L, 0L, -1L)
  if (digit * length(base_pattern) < n + 1L) {
    m <- ceiling((n + 1L) / (length(base_pattern) * digit))
    res <- rep(base_pattern, each = digit) %>% 
      rep(m) %>% 
      tail(-1L) %>% 
      extract(1:n)
  } else {
    times <- rep(digit, (n + 1L) %/% digit)
    m <- sum(times)
    if (m < (n + 1L)) {
      times <- c(times, n + 1 - m)
    }
    res <- rep(base_pattern[seq_along(times)], times) %>% 
      tail(-1L)
  }
  res
}


fft <- function(signal, nr_phases) {
  n <- length(signal)
  patterns <- map(seq_len(n), ~ get_pattern(.x, n))
  .fft <- function(x) {
    map_int(seq_len(n), ~ abs(sum(x * patterns[[.x]])) %% 10L)
  }
  for (i in seq_len(nr_phases)) {
    signal <- .fft(signal)
  }
  signal[1:min(8L, n)] %>% 
    paste(collapse = "")
}

fft(puzzle_data, 100L)

fft_phase <- function(signal) {
  out <- signal
  for (i in (length(out) - 1L):1) {
    out[i] <- (out[i] + out[i + 1L]) %% 10L
  }
  out
}

fft_phase <- function(signal) {
  out <- rev(signal)
  rev(cumsum(out) %% 10L)
}

```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

```{r helper-fns, include = FALSE}
fmt <- function(x) {
  as.integer(x) %>% 
    format(big.mark = ".", decimal.mark = ",")
}
```


For the second part, we have to be way smarter. We observe the following properties of the
patterns.

1. Let `n` denote the length of the input signal and $i$ the position of a digit. If `i` 
is greater than `n/2`, the pattern looks like this `0,0,0,...,1,1,1`, that is we have a 
block of `0` in the beginning and a block of `1` in the end.
1. That is, to calculate any digit for the second half of the input, we just need to build
the cumulative sum from the right  (and take it modulo 10).
1. Our offset is 
`r paste(puzzle_data[1:7], collapse = "") %>% fmt()` which is greater than 
`10000 * |x| / 2` (`r fmt(10000L * length(puzzle_data) / 2L)` ). Thus, all we need to do
is to calculate the digits from the offset until the end using the cumulative sum.

```{r get-solution-2}
fft_offset <- function(signal, nr_phases, rep_factor = 10000L) {
  n <- length(signal) * rep_factor
  offset <- signal[1:7] %>% 
    paste(collapse = "") %>% 
    as.integer()
  stopifnot(offset >= n / 2L)
  tail_len <- n - offset
  tail <- signal[(offset + seq_len(tail_len) - 1L) %% length(signal) + 1L]
  for (p in seq_len(nr_phases)) {
    tail <- rev(cumsum(rev(tail)) %% 10L)
  }
  paste(tail[1:8], collapse = "")
}
fft_offset(puzzle_data, 100L, 10000L)
```
