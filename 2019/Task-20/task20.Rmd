---
params:
   task_nr: 20
   year: 2019
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  maze <- text_block %>% 
    str_split("") %>% 
    do.call(rbind, .)
  n <- nrow(maze)
  m <- ncol(maze)
  hole <- apply(maze, 1L, \(r) sum(r %in% c(".", "#")))
  rng <- range(hole)
  hole_rows <- which(!hole %in% rng) %>% 
    range()
  row_idx <- c(1L, hole_rows[1L], hole_rows[2L] - 1L, n - 1L)
  rows <- apply(maze[row_idx, ], 1L, str_which, "[A-Z]")
  
  hole <- apply(maze, 2L, \(r) sum(r %in% c(".", "#")))
  rng <- range(hole)
  hole_cols <- which(!hole %in% rng) %>% 
    range()
  col_idx <- c(1L, hole_cols[1L],hole_cols[2L] - 1L, m - 1L)
  cols <- apply(maze[, col_idx], 2L, str_which, "[A-Z]")
  offset <- 1L
  for (ri in seq_along(row_idx)) {
    i <- row_idx[ri]
    ci <- rows[[ri]]
    maze[i + offset, ci] <- apply(maze[seq(i, length.out = 2L), ci], 2L, 
                                  paste0, collapse = "")
    maze[i + offset, ci - 1L] <- "#"
    maze[i + offset, ci + 1L] <- "#"
    offset <- (offset + 1L) %% 2L
    maze[i + offset, ci] <- "#"
    maze[i + offset, ci - 1L] <- "#"
    maze[i + offset, ci + 1L] <- "#"
  }
  for (ci in seq_along(col_idx)) {
    j <- col_idx[ci]
    ri <- cols[[ci]]
    maze[ri, j + offset] <- apply(maze[ri, seq(j, length.out = 2L)], 1L,
                                  paste0, collapse = "")
    maze[ri - 1L, j + offset] <- "#"
    maze[ri + 1L, j + offset] <- "#"
    offset <- (offset + 1L) %% 2L
    maze[ri, j + offset] <- "#"
    maze[ri - 1L, j + offset] <- "#"
    maze[ri + 1L, j + offset] <- "#"
  }
  ## recode portals to 1 LETTER 
  all_portals <- str_extract(maze, "..") %>% 
    na.omit() %>% 
    unique() %>% 
    sort()
  lkp <- c(LETTERS, letters[seq(1L, length.out = length(all_portals) - 26L)]) %>% 
    set_names(all_portals) %>% 
    c("." = ".", " " = " ", "#" = "#", .)
  maze[] <- lkp[c(maze)]
  warp <- map(lkp[-(1:3)], function(ptl) {
    which(maze == ptl, arr.ind = TRUE)
  }) %>% 
    set_names(lkp[-(1:3)])
  structure(maze, class = "maze", start = "A", goal = tail(lkp, 1L), warp = warp)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

```{r get-solution-1}
print.maze <- function(x, ...) {
  apply(x, 1, paste, collapse = "") %>% 
    paste(collapse = "\n") %>% 
    cat()
  invisible(x)
}

find_shortest_path <- function(maze = puzzle_data) {
  dir <- rbind(
    "^" = c(-1L, 0L),
    ">" = c(0L, 1L),
    "v" = c(1L, 0L),
    "<" = c(0L, -1L)
  )
  
  warp <- attr(maze, "warp")
  start <- attr(maze, "start")
  goal <- attr(maze, "goal")
  
  walk_out <- function(pos) {
    for (i in seq_len(nrow(dir))) {
      new_pos <- pos + dir[i, , drop = FALSE]
      if (maze[new_pos] == ".") {
        return(new_pos)
      }
    }
    
  }
  n <- nrow(maze)
  m <- ncol(maze)
  dist <- matrix(-1L, n, m)
  start_pos <- which(maze == start, arr.ind = TRUE) 
  dist[start_pos] <- 0L
  start_pos <- walk_out(start_pos)
  dist[start_pos] <- 0L
  queue <- matrix(NA_integer_, n * m, 2L)
  head_ptr <- tail_ptr <- 1L
  queue[head_ptr, ] <- start_pos
  while (head_ptr <= tail_ptr) {
    cur_pos <- queue[head_ptr, , drop = FALSE]
    head_ptr <- head_ptr + 1L
    nbs <- t(t(dir) + c(cur_pos))
    valid_nbs <- between(nbs[, 1L], 1L, n) &
      between(nbs[, 2L], 1L, m) &
      !maze[nbs] %in% c(" ", "#")
    nbs <- nbs[valid_nbs, , drop = FALSE]
    for (i in seq_len(nrow(nbs))) {
      nb <- nbs[i, , drop = FALSE]
      if (maze[nb] == goal) {
        return(dist[cur_pos])
      } else if (maze[nb] %in% names(warp)) {
        # warp
        targets <- warp[[maze[nb]]]
        for (j in seq_len(nrow(targets))) {
          target <- targets[j, , drop = FALSE]
          if (!all(target == nb)) {
            nb <- walk_out(target)
            break
          }
        }
      }
      if (dist[nb] == -1L) {
        dist[nb] <- dist[cur_pos] + 1L
        tail_ptr <- tail_ptr + 1L
        queue[tail_ptr, ] <- nb
      }
    }
  }
  NA_integer_
}

find_shortest_path(puzzle_data)
```

For the second part, we analyse the map. First observation is that straight lines are 
either `r combine_words(unique(unlist(path_lengths)), and = " or ", oxford_comma = FALSE)`
fields long.

```{r show-path-length}
<<path-length>>
```

Then, we collected the segment lengths, assuming that we do not turn at intersection 
points. Once, we had the segment lengths, we were looking for recurring patterns, and
we could identify that this program let the robot stay on the scaffold:

* **Program**: `A,B,A,C,B,C,B,A,C,B`
* **A**: `L,6,R,8,R,12,L,6,L,8`
* **B**: `L,10,L,8,R,12`
* **C**: `L,8,L,10,L,6,L,6`

*N.B.* In an earlier version, we used a too long variant of `C`, but it turned out that 
this is basically `B` so we could rmeove it form `C` and add `Bs` instead to the program.

This screenshot shows the process and the paths lengths:

```{r show-solving-step, echo = FALSE}
include_graphics(here::here("2019", "Task-17", "scaffold.png"))
```

Eventually, we tested this walk and the robot stays safe:

```{r test-walk}
test_walk <- function(scaffold, program, funs) {
  pos <- which(scaffold == "^", arr.ind = TRUE)
  for (p in program) {
    steps <- funs[[p]]
    for (s in steps) {
      if (s %in% c("L", "R")) {
        rbt <- scaffold[pos]
        if (s == "L") {
          rbt <- case_when(
            rbt == "^" ~ "<",
            rbt == ">" ~ "^",
            rbt == "v" ~ ">",
            rbt == "<" ~ "v"
          )
        } else {
          rbt <- case_when(
            rbt == "^" ~ ">",
            rbt == ">" ~ "v",
            rbt == "v" ~ "<",
            rbt == "<" ~ "^"
          )
        }
        scaffold[pos] <- rbt
      } else {
        n <- as.integer(s)
        rbt <- scaffold[pos]
        dir <- switch(rbt,
                      "^" = cbind(seq(-1L, by = -1L, length.out = n), 0L),
                      ">" = cbind(0L, seq(1L, by = 1L, length.out = n)),
                      "v" = cbind(seq(1L, by = 1L, length.out = n), 0L),
                      "<" = cbind(0L, seq(-1L, by = -1L, length.out = n))
        )
        if (any(scaffold[t(t(dir) + c(pos))] == ".")) {
          return(FALSE)
        }
        scaffold[pos] <- "#"
        pos <- pos + tail(dir, 1L)
        scaffold[pos] <- rbt
      }
    }
  }
  TRUE
}

program <- c("A", "B", "A", "C", "B", "C", "B", "A", "C", "B")
fns <- list(A = c("L", 6, "R", 8, "R", 12, "L", 6, "L", 8),
               B = c("L", 10, "L", 8, "R", 12),
               C = c("L", 8, "L", 10, "L", 6, "L", 6))
test_walk(scaffold, program, fns)
```

Now we can feed these parameters to the intcode compiler.

```{r get-solution-2}
encode_input <- function(program, fns) {
  encode <- function(x) { 
    paste(x, collapse = ",") %>% 
      paste0("\n") %>% 
      charToRaw() %>% 
      as.integer()
  }
  program <- encode(program)
  fns <- map(fns, encode)
  
  c(program, unlist(fns), charToRaw("n\n") %>% as.integer()) %>% 
    unname()
}
mission <- puzzle_data
mission[1] <- 2L
tail(parse_op_codes_fast(mission, encode_input(program, fns)), 1L)
```

