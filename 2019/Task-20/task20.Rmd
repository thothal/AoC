---
params:
   task_nr: 20
   year: 2019
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  maze <- text_block %>% 
    str_split("") %>% 
    do.call(rbind, .)
  n <- nrow(maze)
  m <- ncol(maze)
  hole <- apply(maze, 1L, \(r) sum(r %in% c(".", "#")))
  rng <- range(hole)
  hole_rows <- which(!hole %in% rng) %>% 
    range()
  row_idx <- c(1L, hole_rows[1L], hole_rows[2L] - 1L, n - 1L)
  rows <- apply(maze[row_idx, ], 1L, str_which, "[A-Z]")
  
  hole <- apply(maze, 2L, \(r) sum(r %in% c(".", "#")))
  rng <- range(hole)
  hole_cols <- which(!hole %in% rng) %>% 
    range()
  col_idx <- c(1L, hole_cols[1L],hole_cols[2L] - 1L, m - 1L)
  cols <- apply(maze[, col_idx], 2L, str_which, "[A-Z]")
  offset <- 1L
  for (ri in seq_along(row_idx)) {
    i <- row_idx[ri]
    ci <- rows[[ri]]
    maze[i + offset, ci] <- apply(maze[seq(i, length.out = 2L), ci], 2L, 
                                  paste0, collapse = "")
    maze[i + offset, ci - 1L] <- "#"
    maze[i + offset, ci + 1L] <- "#"
    offset <- (offset + 1L) %% 2L
    maze[i + offset, ci] <- "#"
    maze[i + offset, ci - 1L] <- "#"
    maze[i + offset, ci + 1L] <- "#"
  }
  for (ci in seq_along(col_idx)) {
    j <- col_idx[ci]
    ri <- cols[[ci]]
    maze[ri, j + offset] <- apply(maze[ri, seq(j, length.out = 2L)], 1L,
                                  paste0, collapse = "")
    maze[ri - 1L, j + offset] <- "#"
    maze[ri + 1L, j + offset] <- "#"
    offset <- (offset + 1L) %% 2L
    maze[ri, j + offset] <- "#"
    maze[ri - 1L, j + offset] <- "#"
    maze[ri + 1L, j + offset] <- "#"
  }
  ## recode portals to 1 LETTER 
  all_portals <- str_extract(maze, "..") %>% 
    na.omit() %>% 
    unique() %>% 
    sort()
  lkp <- c(LETTERS, letters[seq(1L, length.out = length(all_portals) - 26L)]) %>% 
    set_names(all_portals) %>% 
    c("." = ".", " " = " ", "#" = "#", .)
  maze[] <- lkp[c(maze)]
  warp <- map(lkp[-(1:3)], function(ptl) {
    which(maze == ptl, arr.ind = TRUE)
  }) %>% 
    set_names(lkp[-(1:3)])
  structure(maze, class = "maze", start = "A", goal = tail(lkp, 1L), warp = warp)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We solve the first part by a straight forward BFS, where we just have to make sure that 
entering a warp field moves the current position on the field before the warp field.


```{r get-solution-1}
print.maze <- function(x, ...) {
  apply(x, 1, paste, collapse = "") %>% 
    paste(collapse = "\n") %>% 
    cat()
  invisible(x)
}

find_shortest_path <- function(maze = puzzle_data) {
  dir <- rbind(
    "^" = c(-1L, 0L),
    ">" = c(0L, 1L),
    "v" = c(1L, 0L),
    "<" = c(0L, -1L)
  )
  
  warp <- attr(maze, "warp")
  start <- attr(maze, "start")
  goal <- attr(maze, "goal")
  
  walk_out <- function(pos) {
    for (i in seq_len(nrow(dir))) {
      new_pos <- pos + dir[i, , drop = FALSE]
      if (maze[new_pos] == ".") {
        return(new_pos)
      }
    }
  }
  n <- nrow(maze)
  m <- ncol(maze)
  dist <- matrix(-1L, n, m)
  start_pos <- which(maze == start, arr.ind = TRUE) 
  dist[start_pos] <- 0L
  start_pos <- walk_out(start_pos)
  dist[start_pos] <- 0L
  queue <- matrix(NA_integer_, n * m, 2L)
  head_ptr <- tail_ptr <- 1L
  queue[head_ptr, ] <- start_pos
  while (head_ptr <= tail_ptr) {
    cur_pos <- queue[head_ptr, , drop = FALSE]
    head_ptr <- head_ptr + 1L
    nbs <- t(t(dir) + c(cur_pos))
    valid_nbs <- between(nbs[, 1L], 1L, n) &
      between(nbs[, 2L], 1L, m) &
      !maze[nbs] %in% c(" ", "#") &
      dist[nbs] == -1L
    nbs <- nbs[valid_nbs, , drop = FALSE]
    for (i in seq_len(nrow(nbs))) {
      nb <- nbs[i, , drop = FALSE]
      if (maze[nb] == goal) {
        return(dist[cur_pos])
      } else if (maze[nb] %in% names(warp)) {
        # warp
        targets <- warp[[maze[nb]]]
        dist[nb] <- dist[cur_pos]
        for (j in seq_len(nrow(targets))) {
          target <- targets[j, , drop = FALSE]
          if (!all(target == nb)) {
            dist[target] <- dist[cur_pos]
            nb <- walk_out(target)
            break
          }
        }
      }
      dist[nb] <- dist[cur_pos] + 1L
      tail_ptr <- tail_ptr + 1L
      queue[tail_ptr, ] <- nb
    }
  }
  NA_integer_
}

find_shortest_path(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part we use an A*-algorithm. For this we first calculate the distances
between all warp points

```{r get-solution-2}
bfs <- function(maze, start_pos) {
  dir <- rbind(
    "^" = c(-1L, 0L),
    ">" = c(0L, 1L),
    "v" = c(1L, 0L),
    "<" = c(0L, -1L)
  )
  
  warp <- attr(maze, "warp")
  
  walk_out <- function(pos) {
    for (i in seq_len(nrow(dir))) {
      new_pos <- pos + dir[i, , drop = FALSE]
      if (maze[new_pos] == ".") {
        return(new_pos)
      }
    }
  }
  
  is_outer <- function(pos) {
    pos[1L] %in% c(2L, n - 1) ||
      pos[2L] %in% c(2L, m - 1)
  }
  n <- nrow(maze)
  m <- ncol(maze)
  start <- maze[start_pos]
  dist <- matrix(-1L, n, m)
  dist[start_pos] <- 0L
  start_outer <- is_outer(start_pos)
  start_pos <- walk_out(start_pos)
  dist[start_pos] <- 0L
  queue <- matrix(NA_integer_, n * m, 2L)
  head_ptr <- tail_ptr <- 1L
  queue[head_ptr, ] <- start_pos
  res <- tibble(from = character(0L),
                to = character(0L),
                distance = integer(0L), 
                from_outer = logical(0L),
                to_outer = logical(0L))
  while (head_ptr <= tail_ptr) {
    cur_pos <- queue[head_ptr, , drop = FALSE]
    head_ptr <- head_ptr + 1L
    nbs <- t(t(dir) + c(cur_pos))
    valid_nbs <- between(nbs[, 1L], 1L, n) &
      between(nbs[, 2L], 1L, m) &
      !maze[nbs] %in% c(" ", "#") &
      dist[nbs] == -1L
    nbs <- nbs[valid_nbs, , drop = FALSE]
    for (i in seq_len(nrow(nbs))) {
      nb <- nbs[i, , drop = FALSE]
      if (maze[nb] %in% names(warp)) {
        dist[nb] <- dist[cur_pos]
        res <- add_row(res,
                       from = start,
                       to = maze[nb],
                       distance = dist[cur_pos],
                       from_outer = start_outer,
                       to_outer = is_outer(nb))
      }
      dist[nb] <- dist[cur_pos] + 1L
      tail_ptr <- tail_ptr + 1L
      queue[tail_ptr, ] <- nb
    }
  }
  res
}

precompute_distances <- function(maze = puzzle_data) {
  warp <- attr(maze, "warp")
  map(warp, function(wp) {
    res <- vector("list", nrow(wp))
    for (i in seq_len(nrow(wp))) {
      pos <- wp[i, , drop = FALSE]
      res[[i]] <- bfs(maze, pos)
    }
    list_rbind(res)
  }) %>% 
    list_rbind()
}

summarize_path <- function(dist, start, visited) {
  cur <- start
  is_linear <- TRUE
  weight <- 0L
  visited <- c(visited, cur)
  while(is_linear) {
    cand <- dist %>% 
      filter(from == cur, !to %in% visited)
    is_linear <- nrow(cand) == 1L
    if (is_linear) {
            cur <- cand %>% pull(to)
      visited <- c(visited, cur)
      weight <- weight + cand %>% pull(distance)

    }
  }
  tibble(from = start,
         to = tail(visited, 1L),
         distance = weight,
         lvl = sum(str_count(tail(visited, -2L), "_o$")))
}
warp_distances <- precompute_distances(puzzle_data)
```



