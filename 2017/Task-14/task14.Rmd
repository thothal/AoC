---
params:
   task_nr: 14
   year: 2017
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution

We reuse the hash function from [Day 10 @ 2017](2017_task10.html) and fill the grid with 
the calculated hashes.

```{r get-solution-1}
knot_hash <- function(word) {
  n <- 256L
  lengths <- word %>% 
    utf8ToInt() %>% 
    c(., 17L, 31L, 73L, 47L, 23L)
  stream <- seq(0L, n - 1L)
  pos <- 1L
  skip_size <- 0L
  for (round in 1:64) {
    for (l in lengths) {
      idx <- (seq(pos, by = 1L, length.out = l) - 1L) %% n + 1L
      stream[idx] <- rev(stream[idx])
      pos <- (pos + l + skip_size - 1L) %% n + 1L
      skip_size <- skip_size + 1L
    }
  }
  m <- matrix(stream, 16L, 16L)
  apply(m, 2L, function(col) {
    Reduce(bitwXor, col)
  }) %>% 
    as.hexmode() %>% 
    format(2) %>% 
    str_split("") %>% 
    unlist() %>% 
    strtoi(base = 16L) %>% 
    map(~ intToBits(.x) %>% 
          extract(4:1) %>% 
          as.integer()) %>%
    do.call(c, .)
}

get_bit_matrix <- function(key_string = puzzle_data) {
  m <- matrix(NA, 128L, 128L)
  for (i in 1:nrow(m)) {
    m[i, ] <- knot_hash(paste0(key_string, "-", i - 1L))
  }
  m
}

bm <- get_bit_matrix(puzzle_data)

sum(bm)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

We use the bit matrix and define a recursive function, which marks all regions:

1. Keep track of visited bits.
1. Start with any set bit and recurse into neighbors which were not yet visited and have
a set bit too and update the visited bits information.
1. If none such neighbor exists, increase the region counter and continue with the next 
unvisited set bit.
1. If all set bits were visited return the region counter.

```{r get-solution-2}
count_regions <- function(bm) {
  dd <- dim(bm)
  visited <- matrix(FALSE, dd[1L], dd[2L])
  visited[bm == 0L] <- TRUE
  region_cnt <- 0L
  dir <- rbind(
    ">" = c(0L, 1L),
    "v" = c(1L, 0L),
    "<" = c(0L, -1L),
    "^" = c(-1L, 0L)
  )
  mark <- function(pos, region_cnt) {
    visited[pos] <<- TRUE
    nbs <- t(t(dir) + c(pos))
    nbs <- nbs[between(nbs[, 1L], 1L, dd[1L]) & 
                 between(nbs[, 2L], 1L, dd[2L]), , drop = FALSE]
    idx <- bm[nbs] == 1 & !visited[nbs]
    nbs <- nbs[idx, , drop = FALSE]
    if (any(idx)) {
      for (i in 1:nrow(nbs)) {
        Recall(nbs[i, , drop = FALSE], region_cnt)  
      }
    }
  }
  while (!all(visited)) {
    region_cnt <- region_cnt + 1L
    start <- which(!visited, arr.ind = TRUE)[1L, , drop = FALSE]
    mark(start, region_cnt)
  }
  region_cnt
}
count_regions(bm)
```
