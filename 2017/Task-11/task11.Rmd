---
params:
   task_nr: 11
   year: 2017
title: '`r paste("<span>Task", params$task_nr, "<span class = \"back\"><a href = \"index.html\">", fontawesome::fa("home"), "</a></span></span>")`'
author: 
  name: "Thorn Thaler"
  email: "thorn.thaler@thothal.at"
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
   year <- basename(dirname(dirname(inputFile)))
   
   o_file <- sprintf("%s_%s", year, 
                     tools::file_path_sans_ext(basename(inputFile)))
                     
   rmarkdown::render(inputFile, encoding = encoding, 
                     output_file = o_file, output_dir = here::here("docs"))
   })
output: 
  rmdformats::downcute:
    highlight: tango
    use_bookdown: TRUE
    mathjax: NULL
    lightbox: TRUE
    gallery: TRUE
editor_options: 
  chunk_output_type: console
---

```{css custom-css, echo = FALSE}
.page-content  .figure {
  width: 100%;
}

.back {
  font-size: 2rem;
}

.day-desc {
  border: 2px dotted;
  border-radius: 6px;
  border-color: var(--blockquote-border-color);
  padding: 0 20px;
}
```


```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.align = "center",
                      dev.args = list(bg = "transparent"))
## Define a function to write text in typewriter font
tt <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", as.character(x))
  } else if (knitr::is_html_output()) {
    sprintf("<tt>%s</tt>", as.character(x))
  } else {
    x
  }
}

```

# Setup

## Libraries

```{r libs, warning = FALSE}
library(httr)
library(xml2)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
```

## Retrieve Data from `r tt("AoC")`


```{r get-data, cache = FALSE, messages = FALSE}
session_cookie <- set_cookies(session = keyring::key_get("AoC-GitHub-Cookie"))
base_url <- paste0("https://adventofcode.com/", params$year, "/day/", params$task_nr)
puzzle <- GET(base_url,
              session_cookie) %>% 
  content(encoding = "UTF-8") %>% 
  xml_find_all("///article") %>% 
  lapply(as.character)

parse_puzzle_data <- function(text_block = readClipboard()) {
  if (length(text_block) == 1L) {
    text_block <- text_block %>% 
      str_split("\n") %>% 
      extract2(1L) %>% 
      keep(nzchar)
  }
  text_block %>% 
    str_split(",") %>% 
    extract2(1L)
}

puzzle_data <- local({
  GET(paste0(base_url, "/input"),
      session_cookie) %>% 
    content(encoding = "UTF-8") %>% 
    parse_puzzle_data()
})
```

```{r example-data, eval = interactive(), echo = FALSE}
```

# Puzzle Day `r params$task_nr`

## Part 1

### Description

```{r show-puzzle-a, echo = FALSE, results = "asis"}
cat(puzzle[[1]])
```

### Solution
To account for the fact that the fields are hexagons, we encode **straight** steps by 
`2 / 0` and `0 / 2` (and their negative counterpart) while **diagonal** steps are encoded 
by `1 / 1` (and all combinations with negative step sizes).

The final position is then simply the sum of the moves and we end up at some coordinates. 
To count the number for steps for this coordinate, we take the smaller of these two values
(taken as absolute values) which would indicate the number of diagonal steps. Then we 
substract this number from the other position and divide by 2 which counts straight
steps.

```{r get-solution-1}
count_moves <- function(dirs) {
  dir <- expand.grid(
    row = -1:1,
    col = -1:1
  ) %>% 
    set_rownames(c("nw", "w", "sw", "n", "x", "s", "ne", "e", "se")) %>% 
    as.matrix()
  dir[, 1L] <- ((dir[, 2L] == 0) + 1L) * dir[, 1L]
  dir[, 2L] <- ((dir[, 1L] == 0) + 1L) * dir[, 2L]
  final_pos <- dir[dirs, , drop = FALSE] %>% 
    colSums()
  diagonal_moves <- min(abs(final_pos))
  straight_moves <- abs(final_pos) %>% 
    range() %>% 
    diff() %>% 
    divide_by(2L)
  diagonal_moves + straight_moves
}
count_moves(puzzle_data)
```

## Part 2

### Description

```{r show-puzzle-b, echo = FALSE, results = "asis", eval = length(puzzle) > 1}
cat(puzzle[[2]])
```

### Solution

For the second part, we have to keep track about the intermediate steps and return the
maximum distance as per the same logic.

```{r get-solution-2}
count_furthest_move <- function(dirs) {
  dir <- expand.grid(
    row = -1:1,
    col = -1:1
  ) %>% 
    set_rownames(c("nw", "w", "sw", "n", "x", "s", "ne", "e", "se")) %>% 
    as.matrix()
  dir[, 1L] <- ((dir[, 2L] == 0) + 1L) * dir[, 1L]
  dir[, 2L] <- ((dir[, 1L] == 0) + 1L) * dir[, 2L]
  dir <- dir[dirs, , drop = FALSE]
  pos <- cbind(0L, 0L)
  max_moves <- -Inf
  for (step in 1:nrow(dir)) {
    pos <- pos + dir[step, , drop = FALSE]
    diagonal_moves <- min(abs(pos))
    straight_moves <- abs(pos) %>% 
      range() %>% 
      diff() %>% 
      divide_by(2L)
    if (diagonal_moves + straight_moves > max_moves) {
      max_moves <- diagonal_moves + straight_moves
    }
  }
  max_moves
}
count_furthest_move(puzzle_data)
```
